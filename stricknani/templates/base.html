<!DOCTYPE html>
<html lang="{{ current_language }}" class="h-full antialiased transition-colors duration-200">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}{{ _('Stricknani') }}{% endblock %}</title>
    <meta name="csrf-token" content="{{ csrf_token }}">
    {% block head %}{% endblock %}
	    <link rel="icon" type="image/svg+xml"
	        href="{% if is_dev_instance %}/static/favicon-dev.svg{% else %}/static/favicon.svg{% endif %}">
		    <link rel="stylesheet" href="{{ url_for('static', path='vendor/mdi/css/materialdesignicons.min.css') }}">
		    <link rel="stylesheet" href="{{ url_for('static', path='vendor/photoswipe/photoswipe.css') }}">
        <link rel="stylesheet" href="{{ url_for('static', path='css/app.css') }}">
	    <script>
	        window.STRICKNANI = window.STRICKNANI || {};
	        window.STRICKNANI.i18n = {{ {
	            'cancel': _('Cancel'),
            'confirm': _('Confirm'),
            'copiedToClipboard': _('Copied to clipboard'),
            'darkMode': _('Dark Mode'),
            'dismissMessage': _('Dismiss message'),
            'failedToCopy': _('Failed to copy'),
            'lightMode': _('Light Mode'),
            'nothingToPreview': _('Nothing to preview'),
            'onlyImages': _('Only image files are supported'),
            'somethingWentWrong': _('Something went wrong. Please try again'),
            'uploading': _('Uploading...'),
        } | tojson }};
        window.STRICKNANI.toastMessages = {{ {
            'project_created': _('Project created successfully'),
            'project_updated': _('Project updated successfully'),
            'project_deleted': _('Project deleted'),
            'yarn_created': _('Yarn created successfully'),
            'yarn_updated': _('Yarn updated successfully'),
            'yarn_deleted': _('Yarn deleted'),
            'profile_updated': _('Profile updated successfully'),
            'category_created': _('Category created'),
            'category_updated': _('Category updated'),
            'category_deleted': _('Category deleted'),
            'archive_requested': {
                'message': _('Archive snapshot request queued'),
                'variant': 'success',
            },
            'archive_request_unavailable': {
                'message': _('Archive snapshot request unavailable'),
                'variant': 'info',
            },
        } | tojson }};
    </script>
    <script src="{{ url_for('static', path='js/app.js') }}"></script>
	    <script src="{{ url_for('static', path='vendor/cropperjs/cropper.min.js') }}"></script>
    <script>
        // Theme initialization - MUST run before page renders
        (function () {
            let theme = localStorage.getItem('theme');
            if (!theme) {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    theme = 'dark';
                } else {
                    theme = 'light';
                }
            }
            document.documentElement.setAttribute('data-theme', theme);
            // Also set dark class for Tailwind dark mode
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
            }
        })();
    </script>


    <link href="{{ url_for('static', path='vendor/daisyui/daisyui.css') }}" rel="stylesheet" type="text/css" />
    <link href="{{ url_for('static', path='vendor/daisyui/themes.css') }}" rel="stylesheet" type="text/css" />
    <script src="{{ url_for('static', path='vendor/tailwindcss-browser/index.global.js') }}"></script>
    <script src="{{ url_for('static', path='vendor/htmx/htmx.min.js') }}"></script>
	    <script>
	        document.addEventListener('htmx:configRequest', (event) => {
	            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
	            if (csrfToken) {
	                event.detail.headers['X-CSRF-Token'] = csrfToken;
	            }
	        });
	    </script>
	</head>

<body class="min-h-screen bg-base-300 flex flex-col">
    {% import "macros/dialogs.html" as dialogs %}

    {% block navbar %}
    {# Default navbar - pages can override this block #}
    {% endblock %}

	    <main class="flex-grow w-full" {% block main_attrs %}{% endblock %}>
	        {% block content %}{% endblock %}
	    </main>

    <footer class="mt-8 py-4 text-center text-sm text-base-content/70 bg-base-100 border-t border-base-300">
        <span class="mdi mdi-yarn mr-1 align-middle"></span>{{ _('Stricknani') }} v0.1.0 | {{ _('GPL-3.0-only')
        }}
        <a href="https://github.com/pschmitt/stricknani" target="_blank" rel="noopener noreferrer"
            class="ml-2 text-base-content/70 hover:text-base-content" aria-label="GitHub">
            <span class="mdi mdi-github text-lg align-middle"></span>
        </a>
    </footer>

    {% if current_user %}
    <!-- Profile Image Upload Tools -->
    <input type="file" id="profile-image-input" class="hidden" accept="image/*">
	    <dialog id="crop-modal" class="modal modal-bottom sm:modal-middle">
	        <div class="modal-box max-w-lg">
	            <h3 class="font-bold text-lg mb-4">{{ _('Crop Profile Picture') }}</h3>
	            <div id="avatar-crop-container" class="relative h-96 w-full rounded-lg bg-base-300 overflow-hidden">
	                <img id="crop-image" src="" alt="Image to crop" class="max-h-full max-w-full">
	                <div id="avatar-crop-overlay" class="avatar-crop-overlay" aria-hidden="true"></div>
	            </div>
	            <div class="modal-action">
	                {{ dialogs.dialog_cancel(_('Cancel'), id='crop-cancel') }}
	                {{ dialogs.dialog_primary(_('Save & Upload'), icon='mdi-cloud-upload', id='crop-save') }}
            </div>
        </div>
        {{ dialogs.modal_backdrop() }}
    </dialog>

        <script>
            document.addEventListener('DOMContentLoaded', function () {
                let cropper;
                const input = document.getElementById('profile-image-input');
	                const modal = document.getElementById('crop-modal');
	                const cropContainer = document.getElementById('avatar-crop-container');
	                const cropOverlay = document.getElementById('avatar-crop-overlay');
	                const image = document.getElementById('crop-image');
	                const saveBtn = document.getElementById('crop-save');
	                const cancelBtn = document.getElementById('crop-cancel');
	                let targetUserId = {{ current_user.id }};

	                if (!input || !modal || !cropContainer || !cropOverlay || !image || !saveBtn || !cancelBtn) {
	                    return;
	                }

                window.triggerProfileImageUpload = function (userId) {
                    targetUserId = userId || {{ current_user.id }};
                    input.click();
                };

                function getCropperCtor() {
                    // CropperJS v2 UMD exposes `window.Cropper.default`.
                    // CropperJS v1 exposes `window.Cropper` directly.
                    const cropperNamespace = window.Cropper;
                    const ctor = cropperNamespace?.default || cropperNamespace;

                    if (typeof ctor !== 'function') {
                        return null;
                    }

                    return ctor;
                }

	                function configureCropperSelection() {
	                    if (!cropper || typeof cropper.getCropperSelection !== 'function') {
	                        return;
	                    }

                    const selection = cropper.getCropperSelection();
                    if (!selection) {
                        return;
                    }

	                    // Fixed circular crop: keep selection size fixed and let the user move/zoom the image.
	                    selection.setAttribute('aspect-ratio', '1');
	                    selection.setAttribute('initial-coverage', '1');
	                    selection.removeAttribute('movable');
	                    selection.removeAttribute('resizable');
	                }

	                function updateAvatarCropOverlay() {
	                    const w = cropContainer.clientWidth;
	                    const h = cropContainer.clientHeight;
	                    const size = Math.max(0, Math.floor(Math.min(w, h)));
	                    const radius = Math.max(0, Math.floor(size / 2));

	                    cropOverlay.style.setProperty('--avatar-crop-size', `${size}px`);
	                    cropOverlay.style.setProperty('--avatar-crop-radius', `${radius}px`);
	                }

                function getCroppedCanvas() {
                    if (!cropper) {
                        return Promise.reject(new Error('Cropper not initialized'));
                    }

                    // CropperJS v2: export from the selection element.
                    if (typeof cropper.getCropperSelection === 'function') {
                        const selection = cropper.getCropperSelection();
                        if (selection && typeof selection.$toCanvas === 'function') {
                            return selection.$toCanvas({
                                width: 400,
                                height: 400,
                            });
                        }
                    }

                    // CropperJS v1 fallback.
                    if (typeof cropper.getCroppedCanvas === 'function') {
                        return Promise.resolve(cropper.getCroppedCanvas({
                            width: 400,
                            height: 400,
                        }));
                    }

                    return Promise.reject(new Error('Unsupported CropperJS API'));
                }

                input.addEventListener('change', function (e) {
                    const files = e.target.files;
                    if (files && files.length > 0) {
                        const file = files[0];
                        const reader = new FileReader();
                        reader.onload = function (readerEvent) {
                            image.src = readerEvent.target.result;
                            modal.showModal();

                            if (cropper) {
                                cropper.destroy();
                            }

                            const ctor = getCropperCtor();
                            if (!ctor) {
                                showToast('{{ _("Image cropper failed to load") }}', 'error');
                                modal.close();
                                return;
                            }

	                            cropper = new ctor(image, {});
	                            window.requestAnimationFrame(() => {
	                                configureCropperSelection();
	                                updateAvatarCropOverlay();
	                                window.requestAnimationFrame(updateAvatarCropOverlay);
	                            });
	                        };
	                        reader.readAsDataURL(file);
	                    }
	                });

	                window.addEventListener('resize', () => {
	                    if (!modal.open) {
	                        return;
	                    }
	                    updateAvatarCropOverlay();
	                });

                cancelBtn.addEventListener('click', function () {
                    modal.close();
                    input.value = '';
                    if (cropper) {
                        cropper.destroy();
                        cropper = null;
                    }
                });

                saveBtn.addEventListener('click', function () {
                    if (!cropper) {
                        return;
                    }

                    const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');

                    getCroppedCanvas().then((canvas) => {
                        return new Promise((resolve) => {
                            canvas.toBlob(function (blob) {
                                resolve(blob);
                            }, 'image/png');
                        });
                    }).then((blob) => {
                        if (!blob) {
                            showToast('{{ _("Failed to upload image") }}', 'error');
                            return;
                        }

                        const formData = new FormData();
                        formData.append('file', blob, 'avatar.png');

                        const originalText = saveBtn.textContent;
                        saveBtn.textContent = '{{ _("Uploading...") }}';
                        saveBtn.disabled = true;

                        const url = targetUserId === {{ current_user.id }}
                            ? '/user/profile-image'
                            : `/admin/users/${targetUserId}/profile-image`;

                        fetch(url, {
                            method: 'POST',
                            body: formData,
                            headers: {
                                'HX-Request': 'true',
                                ...(csrfToken ? { 'X-CSRF-Token': csrfToken } : {}),
                            }
                        })
                            .then(response => {
                                if (!response.ok) {
                                    if (response.status === 401 || response.status === 403) {
                                        window.showToast?.('{{ _("Your session has expired. Reload the page to continue.") }}', 'error');
                                        window.confirmAction(
                                            '{{ _("Session expired") }}',
                                            '{{ _("Your session has expired. Reload the page to continue.") }}',
                                            () => window.location.reload(),
                                            null,
                                            {
                                                confirmText: '{{ _("Reload page") }}',
                                                cancelText: '{{ _("Cancel") }}',
                                            }
                                        );
                                        throw new Error('Upload failed (CSRF)');
                                    }
                                    throw new Error('Upload failed');
                                }
                                return response.text();
                            })
                            .then(html => {
                                if (targetUserId === {{ current_user.id }}) {
                                    window.location.reload();
                                    return;
                                }

                                const card = document.getElementById(`user-card-${targetUserId}`);
                                if (card) {
                                    const parser = new DOMParser();
                                    const doc = parser.parseFromString(html, 'text/html');

                                    const newCard = doc.getElementById(`user-card-${targetUserId}`);
                                    if (newCard) {
                                        card.replaceWith(newCard);
                                        if (window.htmx) {
                                            window.htmx.process(newCard);
                                        }
                                    }

                                    const newCount = doc.getElementById('user-count');
                                    const currentCount = document.getElementById('user-count');
                                    if (newCount && currentCount) {
                                        currentCount.replaceWith(newCount);
                                    }
                                }

                                modal.close();

                                const editUserDialog = document.getElementById('editUserDialog');
                                if (editUserDialog && editUserDialog.open) {
                                    editUserDialog.close();
                                }

                                showToast('{{ _("Profile picture updated successfully") }}', 'success');
                            })
                            .catch(err => {
                                console.error(err);
                                showToast('{{ _("Failed to upload image") }}', 'error');
                            })
                            .finally(() => {
                                saveBtn.textContent = originalText;
                                saveBtn.disabled = false;
                            });
                    }).catch((err) => {
                        console.error(err);
                        showToast('{{ _("Failed to upload image") }}', 'error');
                    });
                });
            });
        </script>
    {% endif %}

    {% if current_user %}
    <dialog id="globalSearchModal" class="modal modal-top sm:modal-middle backdrop:bg-base-300/80 backdrop:backdrop-blur-sm">
        <div class="modal-box max-w-2xl p-0 overflow-hidden shadow-2xl border border-base-300 bg-base-100 rounded-2xl sm:mt-0 mt-4 mx-2 sm:mx-auto">
            <div class="relative flex items-center border-b border-base-300 px-4 py-2 bg-base-200/50">
                <span class="mdi mdi-magnify text-2xl opacity-40 mr-3"></span>
                <input type="text" id="globalSearchInput"
                    name="q"
                    placeholder="{{ _('Search projects, yarns...') }}"
                    class="input border-none bg-transparent w-full focus:outline-none focus:ring-0 px-0 h-12 text-lg font-medium"
                    hx-get="/search/global"
                    hx-trigger="keyup changed delay:300ms"
                    hx-target="#globalSearchResults"
                    hx-indicator="#globalSearchIndicator"
                    autocomplete="off">
                <div id="globalSearchIndicator" class="htmx-indicator ml-2">
                    <span class="loading loading-spinner loading-sm opacity-40"></span>
                </div>
                <div class="flex items-center gap-1 ml-auto shrink-0 pl-4">
                    <kbd class="kbd kbd-sm bg-base-300 border-base-content/10 font-bold opacity-60">ESC</kbd>
                </div>
            </div>
            <div id="globalSearchResults" class="max-h-[60vh] overflow-y-auto">
                <div class="py-12 text-center text-base-content/30 italic">
                    <span class="mdi mdi-keyboard-outline text-4xl block mb-2"></span>
                    <p>{{ _('Start typing to search...') }}</p>
                </div>
            </div>
            <div class="bg-base-200/50 px-4 py-2 text-[10px] font-bold uppercase tracking-widest opacity-40 flex justify-between border-t border-base-300">
                <span>{{ _('↑↓ to navigate') }}</span>
                <span>{{ _('Enter to select') }}</span>
            </div>
        </div>
        <form method="dialog" class="modal-backdrop">
            <button>close</button>
        </form>
    </dialog>

    <script>
        document.addEventListener('keydown', function(e) {
            // Ctrl+K or Cmd+K
            if ((e.ctrlKey || e.metaKey) && e.key === 'k') {
                e.preventDefault();
                const modal = document.getElementById('globalSearchModal');
                const input = document.getElementById('globalSearchInput');
                if (modal && !modal.open) {
                    modal.showModal();
                    setTimeout(() => input.focus(), 50);
                } else if (modal && modal.open) {
                    modal.close();
                }
            }
        });

        // 2-finger swipe down to open search on mobile
        (function() {
            let touchStartY = 0;
            let isTwoFinger = false;

            document.addEventListener('touchstart', function(e) {
                if (e.touches.length === 2) {
                    isTwoFinger = true;
                    touchStartY = (e.touches[0].pageY + e.touches[1].pageY) / 2;
                } else {
                    isTwoFinger = false;
                }
            }, { passive: true });

            document.addEventListener('touchend', function(e) {
                if (isTwoFinger) {
                    const touchEndY = (e.changedTouches[0].pageY + (e.changedTouches[1] ? e.changedTouches[1].pageY : e.changedTouches[0].pageY)) / 2;
                    const swipeDistance = touchEndY - touchStartY;

                    // If swiped down more than 100px
                    if (swipeDistance > 100) {
                        const modal = document.getElementById('globalSearchModal');
                        const input = document.getElementById('globalSearchInput');
                        if (modal && !modal.open) {
                            modal.showModal();
                            setTimeout(() => input.focus(), 50);
                        }
                    }
                }
                isTwoFinger = false;
            }, { passive: true });
        })();

        // Focus search input when modal is opened via other means (if any)
        document.getElementById('globalSearchModal')?.addEventListener('show', () => {
            setTimeout(() => document.getElementById('globalSearchInput')?.focus(), 50);
        });

        // Navigation within search results using arrow keys
        document.getElementById('globalSearchInput')?.addEventListener('keydown', function(e) {
            if (['ArrowDown', 'ArrowUp', 'Enter'].includes(e.key)) {
                const results = document.querySelectorAll('#globalSearchResults a');
                if (results.length === 0) return;

                let activeIndex = Array.from(results).findIndex(el => el.classList.contains('bg-primary/10'));

                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    results.forEach(el => el.classList.remove('bg-primary/10'));
                    activeIndex = (activeIndex + 1) % results.length;
                    results[activeIndex].classList.add('bg-primary/10');
                    results[activeIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    results.forEach(el => el.classList.remove('bg-primary/10'));
                    activeIndex = (activeIndex - 1 + results.length) % results.length;
                    results[activeIndex].classList.add('bg-primary/10');
                    results[activeIndex].scrollIntoView({ block: 'nearest' });
                } else if (e.key === 'Enter') {
                    if (activeIndex >= 0) {
                        e.preventDefault();
                        results[activeIndex].click();
                    }
                }
            }
        });
    </script>
    {% endif %}

    <div id="toastContainer"
        class="fixed inset-x-4 top-[4.5rem] z-[2147483647] mx-auto flex max-w-sm flex-col gap-3 sm:inset-auto sm:right-4 sm:top-[4.5rem] sm:w-80"
        aria-live="polite" aria-atomic="true"></div>

    <dialog id="confirmationDialog" class="modal modal-bottom sm:modal-middle">
        <div class="modal-box">
            <h3 class="font-bold text-lg" id="confirmationTitle">{{ _('Confirm Action') }}</h3>
            <p class="py-4" id="confirmationMessage">{{ _('Are you sure you want to proceed?') }}</p>
            <div class="modal-action">
                <form method="dialog">
                    {{ dialogs.dialog_cancel(_('Cancel'), type='submit', id='confirmationCancel') }}
                    {{ dialogs.dialog_danger(_('Confirm'), icon='mdi-trash-can-outline', type='button',
                    id='confirmationConfirm') }}
                </form>
            </div>
        </div>
        {{ dialogs.modal_backdrop() }}
    </dialog>

    <dialog id="pdfViewerDialog" class="modal">
        <div class="modal-box w-screen h-screen max-w-none p-0 overflow-hidden rounded-none flex flex-col">
            <div class="flex items-center justify-between gap-4 p-4 border-b border-base-200 bg-base-100">
                <div class="min-w-0">
                    <h3 class="font-bold text-lg" id="pdfViewerTitle">{{ _('Preview') }}</h3>
                    <p class="text-xs text-base-content/60 truncate" id="pdfViewerFilename"></p>
                </div>
                <div class="flex items-center gap-2 shrink-0">
                    <a id="pdfViewerDownload"
                        class="btn btn-ghost btn-sm btn-circle"
                        target="_blank"
                        rel="noreferrer"
                        title="{{ _('Download') }}">
                        <span class="mdi mdi-download text-xl"></span>
                    </a>
                    <form method="dialog">
                        <button class="btn btn-ghost btn-sm btn-circle" aria-label="{{ _('close') }}">
                            <span class="mdi mdi-close text-xl"></span>
                        </button>
                    </form>
                </div>
            </div>
            <div class="flex-1 bg-base-200/30">
                <iframe id="pdfViewerFrame" class="w-full h-full" src="about:blank" title="{{ _('Preview') }}"></iframe>
            </div>
        </div>
        {{ dialogs.modal_backdrop() }}
    </dialog>

    <dialog id="imageViewerDialog" class="modal">
        <div class="modal-box w-screen h-screen max-w-none p-0 overflow-hidden rounded-none flex flex-col">
            <div class="flex items-center justify-between gap-4 p-4 border-b border-base-200 bg-base-100">
                <div class="min-w-0">
                    <h3 class="font-bold text-lg" id="imageViewerTitle">{{ _('Preview') }}</h3>
                    <p class="text-xs text-base-content/60 truncate" id="imageViewerFilename"></p>
                </div>
                <div class="flex items-center gap-2 shrink-0">
                    <a id="imageViewerDownload"
                        class="btn btn-ghost btn-sm btn-circle"
                        target="_blank"
                        rel="noreferrer"
                        title="{{ _('Download') }}">
                        <span class="mdi mdi-download text-xl"></span>
                    </a>
                    <form method="dialog">
                        <button class="btn btn-ghost btn-sm btn-circle" aria-label="{{ _('close') }}">
                            <span class="mdi mdi-close text-xl"></span>
                        </button>
                    </form>
                </div>
            </div>
            <div class="flex-1 bg-black/90 p-3 sm:p-4 overflow-auto">
                <div class="min-h-full flex items-center justify-center">
                <img id="imageViewerImage"
                    class="block max-w-full max-h-full object-contain"
                    src="about:blank"
                    alt="">
                </div>
            </div>
        </div>
        {{ dialogs.modal_backdrop() }}
    </dialog>

    <dialog id="pswpOcrDialog" class="modal modal-bottom sm:modal-middle">
        <div
            class="modal-box w-screen h-screen max-w-none p-0 overflow-hidden rounded-none flex flex-col sm:w-[min(1100px,calc(100vw-4rem))] sm:h-[min(85vh,900px)] sm:rounded-box">
            <div class="flex items-center justify-between gap-4 p-4 border-b border-base-200 bg-base-100">
                <div class="min-w-0">
                    <h3 class="font-bold text-lg">{{ _('OCR') }}</h3>
                    <p class="text-xs text-base-content/60 truncate" id="pswpOcrFilename"></p>
                </div>
                <div class="flex items-center gap-2 shrink-0">
                    <button
                        id="pswpOcrCopy"
                        type="button"
                        class="btn btn-ghost btn-sm btn-circle"
                        title="{{ _('Copy text') }}"
                        aria-label="{{ _('Copy text') }}"
                        disabled
                    >
                        <span class="mdi mdi-content-copy text-xl"></span>
                    </button>
                    <button
                        id="pswpOcrRetry"
                        type="button"
                        class="btn btn-ghost btn-sm btn-circle"
                        title="{{ _('Retry') }}"
                        aria-label="{{ _('Retry') }}"
                    >
                        <span class="mdi mdi-refresh text-xl"></span>
                    </button>
                    <form method="dialog">
                        <button class="btn btn-ghost btn-sm btn-circle" aria-label="{{ _('close') }}">
                            <span class="mdi mdi-close text-xl"></span>
                        </button>
                    </form>
                </div>
            </div>
            <div class="flex-1 min-h-0 bg-base-100 p-4 overflow-auto">
                <div class="flex min-h-0 flex-col">
                    <div id="pswpOcrStatus" class="text-sm text-base-content/70"></div>
                    <div class="relative mt-3 flex-1 min-h-0">
                        <div
                            id="pswpOcrLoadingOverlay"
                            class="absolute inset-0 hidden rounded-lg border border-base-300 bg-base-100/95 backdrop-blur-sm"
                        >
                            <div class="flex h-full w-full items-center justify-center p-4">
                                <div class="flex items-center gap-3 text-base-content/80">
                                    <span
                                        id="pswpOcrSpinner"
                                        class="loading loading-spinner loading-sm text-primary"
                                        aria-hidden="true"
                                    ></span>
                                    <div id="pswpOcrLoadingStatus" class="text-sm"></div>
                                </div>
                            </div>
                        </div>
                        <pre
                            id="pswpOcrText"
                            class="h-full min-h-40 overflow-auto whitespace-pre-wrap break-words rounded-lg border border-base-300 bg-base-100 p-3 text-sm text-base-content/90"
                        ></pre>
                    </div>
                </div>
            </div>
        </div>
        {{ dialogs.modal_backdrop() }}
    </dialog>

    <div id="swipe-indicator-left" class="fixed left-4 top-1/2 -translate-y-1/2 z-[100] transition-all duration-200 opacity-0 pointer-events-none scale-75">
        <div class="bg-base-100/90 backdrop-blur-sm rounded-full p-4 shadow-xl border border-base-content/10 text-primary">
            <span class="mdi mdi-arrow-left text-4xl"></span>
        </div>
    </div>
	    <div id="swipe-indicator-right" class="fixed right-4 top-1/2 -translate-y-1/2 z-[100] transition-all duration-200 opacity-0 pointer-events-none scale-75">
	        <div class="bg-base-100/90 backdrop-blur-sm rounded-full p-4 shadow-xl border border-base-content/10 text-primary">
	            <span class="mdi mdi-arrow-right text-4xl"></span>
	        </div>
	    </div>

	    <script type="module">
	        import PhotoSwipeLightbox from "{{ url_for('static', path='vendor/photoswipe/photoswipe-lightbox.esm.min.js') }}";

	        const lightboxes = window.pswpLightboxes || new Map();
        window.pswpLightboxes = lightboxes;
        const pswpThumbsLabel = "{{ _('Gallery thumbnails') }}";
        const pswpThumbActionLabel = "{{ _('Open image') }}";

        const initGallery = (gallery) => {
            if (!gallery) {
                return null;
            }
            const existing = lightboxes.get(gallery);
            if (existing) {
                return existing;
            }
            const lightbox = new PhotoSwipeLightbox({
                gallery,
                children: 'a[data-pswp-width]',
                pswpModule: () => import("{{ url_for('static', path='vendor/photoswipe/photoswipe.esm.min.js') }}"),
            });

            // Auto-detect dimensions if they are missing or placeholders (1200)
            lightbox.addFilter('domItemData', (itemData, element, link) => {
                if (itemData.width === 1200 && itemData.height === 1200) {
                    const img = element.querySelector('img');
                    if (img && img.naturalWidth && img.naturalHeight) {
                        itemData.width = img.naturalWidth;
                        itemData.height = img.naturalHeight;
                    }
                }
                return itemData;
            });

            lightbox.on('uiRegister', () => {
                if (!lightbox.pswp?.ui) {
                    return;
                }
                const pswp = lightbox.pswp;

                // Register Thumbs
                pswp.ui.registerElement({
                    name: 'thumbs',
                    order: 9,
                    isButton: false,
                    appendTo: 'root',
                    onInit: (el, pswp) => {
                        el.classList.add('pswp__thumbs');
                        el.setAttribute('aria-label', pswpThumbsLabel);
                        el.setAttribute('role', 'toolbar');

                        const buildItems = () => {
                            const count = typeof pswp.getNumItems === 'function'
                                ? pswp.getNumItems()
                                : (pswp.options?.dataSource?.length || pswp.options?.dataSource?.items?.length || 0);
                            el.innerHTML = '';
                            if (!count || count <= 1) {
                                return;
                            }
                            const fragment = document.createDocumentFragment();
                            for (let index = 0; index < count; index += 1) {
                                const item = typeof pswp.getItemData === 'function'
                                    ? pswp.getItemData(index)
                                    : pswp.options?.dataSource?.[index]
                                    || pswp.options?.dataSource?.items?.[index]
                                    || {};
                                const thumbSrc = item?.msrc || item?.src;
                                if (!thumbSrc) {
                                    continue;
                                }
                                const button = document.createElement('button');
                                button.type = 'button';
                                button.className = 'pswp__thumb';
                                button.setAttribute('aria-label', `${pswpThumbActionLabel} ${index + 1}`);
                                button.setAttribute('data-pswp-thumb-index', `${index}`);
                                const img = document.createElement('img');
                                img.src = thumbSrc;
                                img.alt = item?.alt || item?.title || '';
                                button.appendChild(img);
                                button.addEventListener('click', () => {
                                    pswp.goTo(index);
                                });
                                fragment.appendChild(button);
                            }
                            el.appendChild(fragment);
                        };

                        const updateActive = () => {
                            const activeIndex = pswp.currIndex || 0;
                            el.querySelectorAll('[data-pswp-thumb-index]').forEach((button) => {
                                const buttonIndex = Number.parseInt(button.getAttribute('data-pswp-thumb-index') || '0', 10);
                                button.classList.toggle('is-active', buttonIndex === activeIndex);
                            });
                        };

                        buildItems();
                        updateActive();
                        pswp.on('change', updateActive);
                    },
                });

                // Register "Set as primary" button
                pswp.ui.registerElement({
                    name: 'promote-button',
                    ariaLabel: '{{ _("Set as primary") }}',
                    order: 9,
                    isButton: true,
                    html: '<span class="pswp__icn mdi mdi-star"></span>',
                    appendTo: 'bar',
                    onClick: (event, el) => {
                        const item = pswp.currItem;
                        const element = item?.element || item?.data?.element || pswp.currSlide?.data?.element;
                        if (element) {
                            const customEvent = new CustomEvent('pswp:promote', {
                                detail: { element },
                                bubbles: true
                            });
                            element.dispatchEvent(customEvent);
                        }
                    },
                    onInit: (el, pswp) => {
                        const update = () => {
                            const item = pswp.currItem;
                            const element = item?.element || item?.data?.element || pswp.currSlide?.data?.element;
                            const isPromotable = element?.hasAttribute('data-pswp-promote');
                            const isAlreadyPrimary = element?.getAttribute('data-pswp-is-primary') === 'true';

                            el.style.display = isPromotable ? 'inline-flex' : 'none';
                            el.classList.toggle('is-primary', isAlreadyPrimary);
                        };
                        pswp.on('change', update);
                        pswp.on('afterInit', update);
                    }
                });

                // Register Delete button
                pswp.ui.registerElement({
                    name: 'delete-button',
                    ariaLabel: '{{ _("Delete image") }}',
                    order: 8,
                    isButton: true,
                    html: '<span class="pswp__icn mdi mdi-delete"></span>',
                    appendTo: 'bar',
                    onClick: (event, el) => {
                        const item = pswp.currItem;
                        const element = item?.element || item?.data?.element || pswp.currSlide?.data?.element;
                        if (element) {
                            const customEvent = new CustomEvent('pswp:delete', {
                                detail: { element },
                                bubbles: true
                            });
                            element.dispatchEvent(customEvent);
                        }
                    },
                    onInit: (el, pswp) => {
                        const update = () => {
                            const item = pswp.currItem;
                            const element = item?.element || item?.data?.element || pswp.currSlide?.data?.element;
                            const isDeletable = element?.hasAttribute('data-pswp-delete');
                            el.style.display = isDeletable ? 'inline-flex' : 'none';
                        };
                        pswp.on('change', update);
                        pswp.on('afterInit', update);
                    }
                });

                // Register Download button
                pswp.ui.registerElement({
                    name: 'download-button',
                    ariaLabel: '{{ _("Download image") }}',
                    order: 7,
                    isButton: true,
                    tagName: 'a',
                    html: '<span class="pswp__icn mdi mdi-download"></span>',
                    appendTo: 'bar',
                    onInit: (el, pswp) => {
                        el.setAttribute('download', '');
                        el.setAttribute('target', '_blank');
                        el.setAttribute('rel', 'noopener');

                        const update = () => {
                            const href = pswp.currSlide?.data?.src || '';
                            el.href = href;
                            el.setAttribute('href', href);
                        };
                        pswp.on('change', update);
                        pswp.on('afterInit', update);
                    }
                });

	                // Register OCR button (opens a simple dialog outside PhotoSwipe).
	                pswp.ui.registerElement({
	                    name: 'ocr-button',
	                    ariaLabel: '{{ _("Extract text") }}',
	                    order: 6,
	                    isButton: true,
	                    html: '<span class="pswp__icn mdi mdi-text-recognition"></span>',
	                    appendTo: 'wrapper',
	                    onClick: async (event) => {
	                        event.preventDefault();
	                        event.stopPropagation();

	                        const dialog = document.getElementById('pswpOcrDialog');
	                        const statusEl = document.getElementById('pswpOcrStatus');
	                        const loadingStatusEl = document.getElementById('pswpOcrLoadingStatus');
	                        const textEl = document.getElementById('pswpOcrText');
	                        const filenameEl = document.getElementById('pswpOcrFilename');
	                        const copyBtn = document.getElementById('pswpOcrCopy');
	                        const retryBtn = document.getElementById('pswpOcrRetry');
	                        const overlayEl = document.getElementById('pswpOcrLoadingOverlay');

	                        if (!dialog || !statusEl || !loadingStatusEl || !textEl || !filenameEl || !copyBtn || !retryBtn || !overlayEl) {
	                            return;
	                        }

	                        const data = pswp.currSlide?.data || pswp.currItem?.data || pswp.currItem || {};
	                        const src = data?.src || data?.msrc || '';
	                        const alt = data?.alt || data?.title || '';

	                        const setLoading = (isLoading, message = '') => {
	                            dialog.setAttribute('aria-busy', isLoading ? 'true' : 'false');
	                            overlayEl.classList.toggle('hidden', !isLoading);
	                            loadingStatusEl.textContent = message;
	                            if (isLoading) {
	                                copyBtn.disabled = true;
	                                retryBtn.disabled = true;
	                            } else {
	                                retryBtn.disabled = false;
	                            }
	                        };

		                        const renderResult = (text, status) => {
		                            statusEl.textContent = status || '';
		                            textEl.textContent = text || '';
		                            copyBtn.disabled = !text;
		                        };

		                        const runOcr = async (force = false) => {
		                            if (!src) {
		                                renderResult('', '{{ _("This image cannot be processed.") }}');
		                                return;
	                            }

	                            setLoading(true, '{{ _("Extracting text...") }}');
	                            renderResult('', '');

	                            const csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
	                            const headers = {
	                                'Content-Type': 'application/json',
	                                ...(csrfToken ? { 'X-CSRF-Token': csrfToken } : {}),
	                            };

	                            try {
	                                const response = await fetch('/utils/ocr', {
	                                    method: 'POST',
	                                    headers,
	                                    body: JSON.stringify({ src, force }),
	                                });

	                                if (!response.ok) {
	                                    const payload = await response.json().catch(() => ({}));
	                                    const detail = payload?.detail || '';
	                                    if (detail === 'ocr_not_available') {
	                                        statusEl.textContent = '{{ _("OCR is not available on this server.") }}';
	                                    } else if (detail === 'invalid_src') {
	                                        statusEl.textContent = '{{ _("This image cannot be processed.") }}';
	                                    } else {
	                                        statusEl.textContent = '{{ _("OCR failed.") }}';
	                                    }
	                                    return;
	                                }

	                                const payload = await response.json();
	                                const text = (payload?.text || '').trim();
	                                if (!text) {
	                                    renderResult('', '{{ _("No text detected.") }}');
	                                    return;
	                                }

	                                renderResult(text, '{{ _("Text extracted.") }}');
	                            } catch (error) {
	                                console.error('OCR failed', error);
	                                renderResult('', '{{ _("OCR failed.") }}');
	                            } finally {
	                                setLoading(false);
	                            }
	                        };

		                        filenameEl.textContent = alt;
		                        dialog.showModal();

		                        copyBtn.onclick = async () => {
		                            const fullText = textEl.textContent || '';
		                            const selection = window.getSelection?.();
		                            const selectedText = selection ? selection.toString() : '';
		                            const isSelectionInsideTextEl = (() => {
		                                if (!selection || selection.rangeCount === 0) {
		                                    return false;
		                                }
		                                const range = selection.getRangeAt(0);
		                                const container = range.commonAncestorContainer;
		                                const node = container.nodeType === Node.ELEMENT_NODE ? container : container.parentElement;
		                                return !!(node && textEl.contains(node));
		                            })();
		                            const copyUsingSelection = (range) => {
		                                if (!selection) {
		                                    return false;
		                                }
		                                const previousRanges = [];
		                                for (let i = 0; i < selection.rangeCount; i++) {
		                                    previousRanges.push(selection.getRangeAt(i).cloneRange());
		                                }
		                                selection.removeAllRanges();
		                                selection.addRange(range);
		                                const ok = document.execCommand('copy');
		                                selection.removeAllRanges();
		                                for (const previousRange of previousRanges) {
		                                    selection.addRange(previousRange);
		                                }
		                                return ok;
		                            };

		                            // In some browsers, Clipboard API writes can fail inside <dialog>, but copying the
		                            // current selection via execCommand still works. Prefer selection-based copying.
		                            if (isSelectionInsideTextEl && selectedText) {
		                                const ok = document.execCommand('copy');
		                                if (ok) {
		                                    window.showToast?.('{{ _("Copied to clipboard") }}', 'success');
		                                    return;
		                                }
		                                if (typeof window.copyToClipboard === 'function') {
		                                    await window.copyToClipboard(selectedText, copyBtn);
		                                    return;
		                                }
		                                window.showToast?.('{{ _("Copy failed") }}', 'error');
		                                return;
		                            }

		                            if (fullText) {
		                                const range = document.createRange();
		                                range.selectNodeContents(textEl);
		                                const ok = copyUsingSelection(range);
		                                if (ok) {
		                                    window.showToast?.('{{ _("Copied to clipboard") }}', 'success');
		                                    return;
		                                }
		                            }

		                            if (typeof window.copyToClipboard === 'function') {
		                                await window.copyToClipboard(fullText, copyBtn);
		                            } else {
		                                window.showToast?.('{{ _("Copy failed") }}', 'error');
		                            }
		                        };
		                        retryBtn.onclick = async () => {
		                            await runOcr(true);
		                        };

	                        await runOcr(false);
	                    },
	                });
	            });
	            lightbox.init();
	            lightboxes.set(gallery, lightbox);
	            return lightbox;
	        };

        window.initPhotoSwipeGallery = initGallery;
        window.refreshPhotoSwipeGallery = (gallery) => {
            const instance = initGallery(gallery);
            if (instance) {
                if (typeof instance.refresh === 'function') {
                    instance.refresh();
                } else if (typeof instance.destroy === 'function') {
                    instance.destroy();
                    lightboxes.delete(gallery);
                    return initGallery(gallery);
                }
            }
            return instance;
        };

        const initAll = () => {
            document.querySelectorAll('[data-pswp-gallery]').forEach((gallery) => {
                initGallery(gallery);
            });
        };

        const markdownLightboxes = new Map();
        const openMarkdownLightbox = (image) => {
            if (!image) {
                return;
            }
            const group = image.getAttribute('data-lightbox-group') || 'markdown';
            const images = Array.from(
                document.querySelectorAll(`img.markdown-inline-image[data-lightbox-group="${group}"]`),
            );
            if (!images.length) {
                return;
            }

            const items = images.map((img) => {
                const src = img.getAttribute('data-lightbox-src') || img.src;
                const alt = img.getAttribute('data-lightbox-alt') || img.alt || '';
                const width = img.naturalWidth || 1200;
                const height = img.naturalHeight || 1200;
                return {
                    src,
                    msrc: img.src,
                    width,
                    height,
                    alt,
                    title: alt,
                    element: img,
                };
            });

            const index = Math.max(0, images.indexOf(image));
            const existing = markdownLightboxes.get(group);
            if (existing) {
                existing.destroy();
                markdownLightboxes.delete(group);
            }

            const lightbox = new PhotoSwipeLightbox({
                dataSource: items,
                pswpModule: () => import("{{ url_for('static', path='vendor/photoswipe/photoswipe.esm.min.js') }}"),
            });
            lightbox.on('close', () => {
                lightbox.destroy();
                markdownLightboxes.delete(group);
            });
            lightbox.init();
            markdownLightboxes.set(group, lightbox);
            lightbox.loadAndOpen(index);
        };

        const openAtIndex = (trigger) => {
            const gallery = trigger.closest('[data-pswp-gallery]');
            if (!gallery) {
                return;
            }
            const raw = trigger.getAttribute('data-pswp-open-index') || '0';
            const index = Number.parseInt(raw, 10);
            const targetIndex = Number.isNaN(index) ? 0 : index;
            const anchors = Array.from(
                gallery.querySelectorAll('a[data-pswp-width]'),
            );
            const target = anchors[targetIndex];
            if (target) {
                target.click();
                return;
            }
            const lightbox = window.refreshPhotoSwipeGallery(gallery);
            if (lightbox) {
                lightbox.loadAndOpen(0, gallery);
            }
        };

        window.openPhotoSwipeIndex = (trigger) => {
            if (!trigger) {
                return;
            }
            openAtIndex(trigger);
        };

        document.addEventListener('click', (event) => {
            const markdownImage = event.target.closest('img.markdown-inline-image');
            if (markdownImage) {
                const src = markdownImage.getAttribute('data-lightbox-src') || markdownImage.src || '';
                if (src.includes('/drops/symbols/') || src.includes('/inline/garnstudio-symbols/')) {
                    return;
                }
                event.preventDefault();
                event.stopPropagation();
                openMarkdownLightbox(markdownImage);
                return;
            }
            const trigger = event.target.closest('[data-pswp-open-index]');
            if (!trigger) {
                return;
            }
            event.preventDefault();
            event.stopPropagation();
            openAtIndex(trigger);
        });

        document.addEventListener('DOMContentLoaded', () => {
            initAll();
        });
    </script>
	    <script>
	        document.addEventListener('DOMContentLoaded', () => {
	            const navDropdowns = document.querySelectorAll('.navbar-nav-dropdown');
	            if (!navDropdowns.length) {
	                return;
            }

	            navDropdowns.forEach((dropdown) => {
	                let closeTimer;
	                const openDropdown = () => {
	                    if (closeTimer) {
                        clearTimeout(closeTimer);
                        closeTimer = null;
                    }
                    dropdown.classList.add('dropdown-open');
                };
                const scheduleClose = () => {
                    if (closeTimer) {
                        clearTimeout(closeTimer);
                    }
                    closeTimer = setTimeout(() => {
                        if (dropdown.matches(':hover')) {
                            return;
                        }
                        if (dropdown.contains(document.activeElement)) {
                            return;
                        }
                        dropdown.classList.remove('dropdown-open');
                    }, 250);
                };

                dropdown.addEventListener('mouseenter', openDropdown);
                dropdown.addEventListener('mouseleave', scheduleClose);
                dropdown.addEventListener('focusin', openDropdown);
	                dropdown.addEventListener('focusout', scheduleClose);
	            });
	        });
	    </script>
	    <script>
	        document.addEventListener('DOMContentLoaded', () => {
	            // Swipe-to-navigate between the primary navbar destinations.
	            // Disabled on primary form pages to avoid conflicts with horizontal gestures while editing.
	            const isPrimaryFormPage = !!document.querySelector('main form[data-primary-form="true"]');
	            if (isPrimaryFormPage) {
	                return;
	            }

	            const mainEl = document.querySelector('main');
	            const detailPrevHref = mainEl?.dataset?.swipePrevHref || '';
	            const detailNextHref = mainEl?.dataset?.swipeNextHref || '';
	            const hasDetailNav = !!(detailPrevHref || detailNextHref);

	            const navMenu = document.querySelector('.navbar-dropdown-nav');
	            const navLinks = navMenu
	                ? Array.from(navMenu.querySelectorAll('a[href]'))
	                    .map((a) => a.getAttribute('href') || '')
	                    .filter((href) => href.startsWith('/'))
	                : [];

                const leftIndicator = document.getElementById('swipe-indicator-left');
                const rightIndicator = document.getElementById('swipe-indicator-right');

	            const isSwipeEligibleTarget = (target) => {
	                if (!target) {
	                    return false;
	                }
	                if (document.querySelector('dialog[open]')) {
	                    return false;
	                }
	                if (document.querySelector('.pswp.pswp--open')) {
	                    return false;
	                }
	                if (target.closest('input, textarea, select, button, a, label, [contenteditable="true"]')) {
	                    return false;
	                }
	                if (target.closest('[data-swipe-nav-ignore]')) {
	                    return false;
	                }
	                return true;
	            };

	            const findCurrentIndex = () => {
	                if (navLinks.length < 2) {
	                    return -1;
	                }
	                const pathname = window.location.pathname || '/';
	                let best = { index: -1, length: -1 };

	                navLinks.forEach((href, index) => {
	                    if (!href) {
	                        return;
	                    }
	                    const isMatch = pathname === href || pathname.startsWith(href + '/');
	                    if (!isMatch) {
	                        return;
	                    }
	                    if (href.length > best.length) {
	                        best = { index, length: href.length };
	                    }
	                });

	                return best.index;
	            };

                const getNextHref = (dx) => {
                    if (dx === 0) return null;
                    const isNext = dx < 0; // Swipe left -> Next

                    if (hasDetailNav) {
                        const detailHref = isNext ? detailNextHref : detailPrevHref;
                        if (detailHref) return detailHref;
                    }

                    const currentIndex = findCurrentIndex();
                    if (currentIndex === -1) return null;

                    const nextIndex = isNext ? currentIndex + 1 : currentIndex - 1;
                    if (nextIndex >= 0 && nextIndex < navLinks.length) {
                        return navLinks[nextIndex];
                    }
                    return null;
                };

                const updateIndicators = (dx, opacity) => {
                    if (!leftIndicator || !rightIndicator) return;

                    // Reset
                    leftIndicator.style.opacity = '0';
                    leftIndicator.style.transform = 'translate(0, -50%) scale(0.75)';
                    rightIndicator.style.opacity = '0';
                    rightIndicator.style.transform = 'translate(0, -50%) scale(0.75)';

                    if (Math.abs(dx) < 10) return;

                    const href = getNextHref(dx);
                    if (!href) return;

                    const target = dx > 0 ? leftIndicator : rightIndicator;
                    target.style.opacity = opacity;
                    // Slide in slightly
                    const slide = Math.min(20, Math.abs(dx) * 0.1);
                    const scale = 0.75 + (opacity * 0.25);
                    const translate = dx > 0 ? `${slide}px` : `-${slide}px`;
                    target.style.transform = `translate(${translate}, -50%) scale(${scale})`;
                };

                const hideIndicators = () => {
                    if (leftIndicator) leftIndicator.style.opacity = '0';
                    if (rightIndicator) rightIndicator.style.opacity = '0';
                };

	            let startX = 0;
	            let startY = 0;
	            let touchTarget = null;
	            let cancelled = false;

	            const thresholdX = 60; // px
	            const thresholdY = 70; // px

	            document.addEventListener('touchstart', (event) => {
	                if (!event.touches || event.touches.length !== 1) {
	                    return;
	                }
	                const target = event.target;
	                if (!isSwipeEligibleTarget(target)) {
	                    touchTarget = null;
	                    return;
	                }

	                const touch = event.touches[0];
	                startX = touch.clientX;
	                startY = touch.clientY;
	                touchTarget = target;
	                cancelled = false;
                    hideIndicators();
	            }, { passive: true });

	            document.addEventListener('touchmove', (event) => {
	                if (!touchTarget || !event.touches || event.touches.length !== 1) {
	                    return;
	                }
	                const touch = event.touches[0];
	                const dx = touch.clientX - startX;
	                const dy = touch.clientY - startY;

	                if (Math.abs(dy) > thresholdY) {
	                    cancelled = true;
                        hideIndicators();
                        return;
	                }

                    if (cancelled) return;

                    // Calculate opacity based on progress to threshold
                    const progress = Math.min(1, Math.abs(dx) / (thresholdX * 1.5));
                    updateIndicators(dx, progress);

	            }, { passive: true });

	            document.addEventListener('touchend', (event) => {
                    hideIndicators();

	                if (!touchTarget || cancelled || !event.changedTouches || event.changedTouches.length !== 1) {
	                    touchTarget = null;
	                    return;
	                }

	                if (!isSwipeEligibleTarget(touchTarget)) {
	                    touchTarget = null;
	                    return;
	                }

	                const touch = event.changedTouches[0];
	                const dx = touch.clientX - startX;
	                const dy = touch.clientY - startY;

	                // Basic horizontal swipe detection.
	                if (Math.abs(dx) < thresholdX) {
	                    touchTarget = null;
	                    return;
	                }
	                if (Math.abs(dy) > thresholdY) {
	                    touchTarget = null;
	                    return;
	                }

                    const href = getNextHref(dx);
                    if (href) {
                        window.location.href = href;
                    }
	                touchTarget = null;
	            }, { passive: true });
	        });
	    </script>
	    {% if sentry_frontend_enabled %}
	    <script src="{{ url_for('static', path='vendor/sentry/bundle.tracing.min.js') }}"></script>
	    <script>
	        Sentry.init({
            dsn: {{ sentry_frontend_dsn | tojson }},
            environment: {{ sentry_frontend_env | tojson }},
            tracesSampleRate: {{ sentry_frontend_traces_sample_rate }}
        });
    </script>
    {% endif %}
</body>

</html>
