async function uploadTitleImage(file) {
        if (!(await ensureProjectId())) return false;

        const formData = new FormData();
        formData.append('file', file);
        formData.append('alt_text', file.name);

        let response;
        try {
            response = await fetch(`/projects/${projectId}/images/title`, {
                method: 'POST',
                headers: {
                    'X-CSRF-Token': '{{ csrf_token }}'
                },
                body: formData,
            });
        } catch (error) {
            console.error('Title image upload failed', error);
            window.showToast?.(uploadNetworkErrorMessage, 'error');
            return false;
        }

        if (!response.ok) {
            const message = await parseErrorMessage(response, uploadErrorMessage);
            window.showToast?.(message, 'error');
            return false;
        }

        const data = await response.json();
        addTitleImageToGallery(data);
        window.unsavedChanges?.setDirty(true);
        return true;
    }

    function addTitleImageToGallery(imageData) {
        const container = document.getElementById('titleImagesContainer');
        if (!container) return;

        container.insertAdjacentHTML('beforeend', createImagePreviewHTML(imageData, {
            showPromote: true,
            isPrimary: false
        }));
        window.refreshPhotoSwipeGallery?.(container);
    }

    function addPendingTitleImageToGallery(url) {
        const container = document.getElementById('titleImagesContainer');
        const div = document.createElement('div');
        div.className = 'relative group';
        div.setAttribute('data-pending-url', url);
        div.innerHTML = `
        <a href="${url}" data-pswp-width="1200" data-pswp-height="1200" data-pswp-caption="" 
            data-pswp-promote="true" data-pswp-delete="true" data-pswp-is-primary="false" 
            draggable="true" ondragstart="handleImageDragStart(event)"
            class="block">
            <img src="${url}" class="h-32 w-full cursor-zoom-in rounded object-cover shadow dark:shadow-slate-900/30">
        </a>
        <button type="button" onclick="promotePendingImage(this, '${url}')"
            class="promote-pending-btn absolute top-1 left-1 z-10 rounded-full p-1 shadow-sm transition-all bg-white/90 text-slate-400 opacity-0 group-hover:opacity-100 dark:bg-slate-900/90 dark:text-slate-500 hover:bg-amber-50 hover:text-amber-600 dark:hover:bg-amber-900/50 dark:hover:text-amber-400"
            title="{{ _('Make title image') }}">
            <span class="mdi mdi-star-outline"></span>
        </button>
        <button type="button" onclick="deletePendingImage(this, '${url}')" class="absolute top-1 right-1 bg-red-600 text-white rounded-full p-1 hover:bg-red-700 dark:hover:bg-red-500 shadow-sm opacity-0 group-hover:opacity-100 transition-opacity">
            <span class="mdi mdi-delete"></span>
        </button>
    `;
        container.appendChild(div);

        // If this is the first image, automatically promote it
        const currentTitleUrl = document.getElementById('import_title_image_url').value;
        if (!currentTitleUrl) {
            promotePendingImage(div.querySelector('.promote-pending-btn'), url);
        }

        window.refreshPhotoSwipeGallery?.(container);
    }

    function promotePendingImage(btn, url) {
        // Update hidden field
        const input = document.getElementById('import_title_image_url');
        if (input) input.value = url;

        // Visual update
        document.querySelectorAll('.promote-pending-btn').forEach(b => {
            b.classList.remove('bg-amber-400', 'text-white', 'opacity-100');
            b.classList.add('bg-white/90', 'text-slate-400', 'opacity-0');
            const star = b.querySelector('span');
            if (star) {
                star.classList.remove('mdi-star');
                star.classList.add('mdi-star-outline');
            }
            const anchor = b.closest('[data-pending-url]')?.querySelector('a[data-pswp-promote]');
            if (anchor) {
                anchor.setAttribute('data-pswp-is-primary', 'false');
            }
        });

        if (btn) {
            btn.classList.add('bg-amber-400', 'text-white', 'opacity-100');
            btn.classList.remove('bg-white/90', 'text-slate-400', 'opacity-0');
            const star = btn.querySelector('span');
            if (star) {
                star.classList.remove('mdi-star-outline');
                star.classList.add('mdi-star');
            }
            const anchor = btn.closest('[data-pending-url]')?.querySelector('a[data-pswp-promote]');
            if (anchor) {
                anchor.setAttribute('data-pswp-is-primary', 'true');
            }
        }
        window.unsavedChanges?.setDirty(true);
    }

    function deletePendingImage(button, url) {
        window.confirmAction(
            '{{ _("Remove Image") }}',
            '{{ _("Remove this image from the import list?") }}',
            () => {
                // Remove visual element
                const container = button.closest('.relative');
                const wasPrimary = document.getElementById('import_title_image_url')?.value === url;
                container?.remove();

                // Update hidden input
                const importInput = document.getElementById('import_image_urls');
                if (importInput && importInput.value) {
                    try {
                        let urls = JSON.parse(importInput.value);
                        urls = urls.filter(u => u !== url);
                        importInput.value = JSON.stringify(urls);
                        if (wasPrimary) {
                            if (urls.length > 0) {
                                const nextUrl = urls[0];
                                const nextBtn = document.querySelector(`[data-pending-url="${CSS.escape(nextUrl)}"] .promote-pending-btn`);
                                promotePendingImage(nextBtn, nextUrl);
                            } else {
                                const titleInput = document.getElementById('import_title_image_url');
                                if (titleInput) {
                                    titleInput.value = '';
                                }
                            }
                        }
                    } catch (e) {
                        console.error('Error updating import_image_urls:', e);
                    }
                } else if (wasPrimary) {
                    const titleInput = document.getElementById('import_title_image_url');
                    if (titleInput) {
                        titleInput.value = '';
                    }
                }
                window.unsavedChanges?.setDirty(true);
            }
        );
    }

    async function deleteImage(imageId) {
        window.confirmAction(
            '{{ _("Delete Image") }}',
            '{{ _("Are you sure you want to delete this image? This action cannot be undone.") }}',
            async () => {
                let response;
                try {
                    response = await fetch(`/projects/${projectId}/images/${imageId}`, {
                        method: 'DELETE',
                        headers: { 'X-CSRF-Token': '{{ csrf_token }}' }
                    });
                } catch (error) {
                    console.error('Image deletion failed', error);
                    window.showToast?.(deleteNetworkErrorMessage, 'error');
                    return;
                }

                if (!response.ok) {
                    const message = await parseErrorMessage(response, deleteErrorMessage);
                    window.showToast?.(message, 'error');
                    return;
                }

                const element = document.querySelector(`[data-image-id="${imageId}"]`);
                if (element) {
                    element.remove();
                }
                window.unsavedChanges?.setDirty(true);
            }
        );
    }

    async function promoteImage(pId, imageId) {
        try {
            const response = await fetch(`/projects/${pId}/images/${imageId}/promote`, {
                method: 'POST',
                headers: {
                    'X-Requested-With': 'XMLHttpRequest',
                    'X-CSRF-Token': '{{ csrf_token }}'
                }
            });

            if (response.ok) {
                // If PhotoSwipe is open, close it before reloading
                if (window.pswpLightboxes) {
                    for (const lb of window.pswpLightboxes.values()) {
                        if (lb.pswp) lb.pswp.close();
                    }
                }
                setPrimaryTitleImage(imageId);
            } else {
                console.error('Failed to promote image');
            }
        } catch (error) {
            console.error('Error promoting image:', error);
        }
    }

    function setPrimaryTitleImage(imageId) {
        const container = document.getElementById('titleImagesContainer');
        if (!container) {
            return;
        }
        container.querySelectorAll('[data-image-id]').forEach((item) => {
            const anchor = item.querySelector('a[data-pswp-promote]');
            if (anchor) {
                anchor.setAttribute('data-pswp-is-primary', 'false');
            }
            const button = item.querySelector('.title-promote-btn');
            if (button) {
                button.classList.remove('bg-amber-400', 'text-white', 'opacity-100');
                button.classList.add('bg-white/90', 'text-slate-400', 'opacity-0');
                const icon = button.querySelector('span');
                if (icon) {
                    icon.classList.remove('mdi-star');
                    icon.classList.add('mdi-star-outline');
                }
            }
        });

        const target = container.querySelector(`[data-image-id="${imageId}"]`);
        if (!target) {
            return;
        }
        const targetAnchor = target.querySelector('a[data-pswp-promote]');
        if (targetAnchor) {
            targetAnchor.setAttribute('data-pswp-is-primary', 'true');
        }
        const targetButton = target.querySelector('.title-promote-btn');
        if (targetButton) {
            targetButton.classList.add('bg-amber-400', 'text-white', 'opacity-100');
            targetButton.classList.remove('bg-white/90', 'text-slate-400', 'opacity-0');
            const icon = targetButton.querySelector('span');
            if (icon) {
                icon.classList.add('mdi-star');
                icon.classList.remove('mdi-star-outline');
            }
        }
        window.unsavedChanges?.setDirty(true);
    }

    // Add event listeners for PhotoSwipe managed actions
    document.addEventListener('pswp:promote', (e) => {
        const anchor = e.detail.element;
        const container = anchor.closest('[data-image-id]');
        if (container) {
            const imageId = container.dataset.imageId;
            if (imageId && projectId) {
                promoteImage(projectId, imageId);
            }
        } else {
            // Handle pending images
            const pendingContainer = anchor.closest('[data-pending-url]');
            if (pendingContainer) {
                const btn = pendingContainer.querySelector('.promote-pending-btn');
                const url = pendingContainer.dataset.pendingUrl;
                if (btn && url) promotePendingImage(btn, url);
            }
        }
    });

    document.addEventListener('pswp:delete', (e) => {
        const anchor = e.detail.element;
        const container = anchor.closest('[data-image-id]');
        if (container) {
            const imageId = container.dataset.imageId;
            if (imageId) {
                // Close PhotoSwipe before showing confirmation
                if (window.pswpLightboxes) {
                    for (const lb of window.pswpLightboxes.values()) {
                        if (lb.pswp) lb.pswp.close();
                    }
                }
                deleteImage(imageId);
            }
        } else {
            // Handle pending images
            const pendingContainer = anchor.closest('[data-pending-url]');
            if (pendingContainer) {
                const url = pendingContainer.dataset.pendingUrl;
                const deleteBtn = pendingContainer.querySelector('button[onclick*="deletePendingImage"]');
                const removeBtn = pendingContainer.querySelector('button[onclick*="removePendingStepImage"]');
                if (window.pswpLightboxes) {
                    for (const lb of window.pswpLightboxes.values()) {
                        if (lb.pswp) lb.pswp.close();
                    }
                }
                if (deleteBtn && url) {
                    deletePendingImage(deleteBtn, url);
                } else if (removeBtn) {
                    removePendingStepImage(removeBtn);
                }
            }
        }
    });

    function initStepImageUploaders() {
        document.querySelectorAll('.step-item').forEach((stepItem) => {
            const dropzone = stepItem.querySelector('.step-image-dropzone');
            const input = stepItem.querySelector('.step-image-input');
            const instructions = dropzone?.querySelector('.upload-instructions');
            const stepId = stepItem.getAttribute('data-step-id');

            if (!dropzone || !input || dropzone.dataset.initialized === 'true') {
                return;
            }

            dropzone.classList.remove(
                'opacity-60',
                'opacity-50',
                'cursor-not-allowed',
                'pointer-events-none',
            );
            dropzone.removeAttribute('aria-disabled');
            if (instructions) {
                instructions.textContent = instructions.dataset.enabledText || uploadInstructionsText;
            }

            window.setupImageUploadWidget(input, dropzone, async (file) => {
                const sid = await ensureStepId(stepItem);
                if (sid) {
                    const data = await uploadStepImage(sid, file);
                    if (data) {
                        addStepImagePreview(stepItem, data);
                    }
                }
            });
        });
    }

    async function ensureStepId(stepItem) {
        if (!(await ensureProjectId())) return null;
        let stepId = stepItem.getAttribute('data-step-id');
        if (stepId) return stepId;

        return await saveStepInternal(stepItem);
    }

    async function uploadStepImage(stepId, file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('alt_text', file.name);

        let response;
        try {
            response = await fetch(`/projects/${projectId}/steps/${stepId}/images`, {
                method: 'POST',
                headers: {
                    'X-CSRF-Token': '{{ csrf_token }}'
                },
                body: formData,
            });
        } catch (error) {
            console.error('Step image upload failed', error);
            window.showToast?.(uploadNetworkErrorMessage, 'error');
            return null;
        }

        if (!response.ok) {
            const message = await parseErrorMessage(response, uploadErrorMessage);
            window.showToast?.(message, 'error');
            return null;
        }

        const data = await response.json();
        window.unsavedChanges?.setDirty(true);
        return data;
    }

    function addStepImagePreview(stepItem, imageData) {
        const imagesContainer = stepItem.querySelector('.step-images');
        if (!imagesContainer) return;

        imagesContainer.insertAdjacentHTML('beforeend', createImagePreviewHTML(imageData, {
            imageClass: 'h-20'
        }));
        window.refreshPhotoSwipeGallery?.(imagesContainer);
        const textarea = stepItem.querySelector('.step-description');
        if (textarea) updateImageVisibility(textarea);
    }

    function initStitchSampleImageUploader() {
        const dropzone = document.getElementById('stitchSampleDropzone');
        const input = document.getElementById('stitchSampleImageInput');

        if (!dropzone || !input || dropzone.dataset.initialized === 'true') {
            return;
        }

        window.setupImageUploadWidget(input, dropzone, async (file) => {
            if (!(await ensureProjectId())) return;

            const formData = new FormData();
            formData.append('file', file);
            formData.append('alt_text', file.name);

            try {
                const response = await fetch(`/projects/${projectId}/images/stitch-sample`, {
                    method: 'POST',
                    headers: {
                        'X-CSRF-Token': '{{ csrf_token }}'
                    },
                    body: formData,
                });

                if (!response.ok) {
                    const message = await parseErrorMessage(response, uploadErrorMessage);
                    window.showToast?.(message, 'error');
                    return;
                }

                const data = await response.json();
                addStitchSampleImagePreview(data);
                window.unsavedChanges?.setDirty(true);
            } catch (error) {
                console.error('Stitch sample image upload failed', error);
                window.showToast?.(uploadNetworkErrorMessage, 'error');
            }
        });
    }

    function addStitchSampleImagePreview(imageData) {
        const container = document.getElementById('stitchSampleImagesContainer');
        if (!container) return;

        container.insertAdjacentHTML('beforeend', createImagePreviewHTML(imageData));
        if (window.refreshPhotoSwipeGallery) {
            window.refreshPhotoSwipeGallery(container);
        }
        const textarea = document.getElementById('stitch_sample');
        if (textarea) updateImageVisibility(textarea);
    }

    initStepImageUploaders();
    initStitchSampleImageUploader();

    document.addEventListener('DOMContentLoaded', () => {
        const titleImageInput = document.getElementById('titleImageInput');
        const titleImageDropZone = document.getElementById('titleImageDropZone');
        if (titleImageInput && titleImageDropZone) {
            window.setupImageUploadWidget(titleImageInput, titleImageDropZone, uploadTitleImage);
        }

        initYarnSelector();
        initTagEditor();

        const importedData = sessionStorage.getItem('importedData');
        if (importedData) {
            try {
                const data = JSON.parse(importedData);
                console.log('[DEBUG] Loading imported data from storage:', data);

                // Prevent re-prompting on save
                isImportPrompted = true;

                const setFieldValue = (id, value) => {
                    const el = document.getElementById(id);
                    if (el && value !== undefined && value !== null) {
                        if (id === 'comment' && el.value.trim().length > 0) return false;
                        el.value = value;
                        if (typeof autoResize === 'function') autoResize(el);
                        return true;
                    }
                    return false;
                };

                const warningBanner = document.getElementById('importWarning');
                if (warningBanner) warningBanner.classList.remove('hidden');

                // Metadata
                setFieldValue('name', data.title || data.name);
                setFieldValue('needles', data.needles);
                setFieldValue('recommended_needles', data.recommended_needles);
                setFieldValue('yarn_brand', data.brand);
                
                const yarnDetailsField = document.getElementById('yarn_details');
                if (yarnDetailsField && data.yarn_details) {
                    yarnDetailsField.value = JSON.stringify(data.yarn_details);
                }

                if (data.yarn) {
                    window.yarnSelector?.selectByName(data.yarn);
                }

                setFieldValue('gauge_stitches', data.gauge_stitches);
                setFieldValue('gauge_rows', data.gauge_rows);
                setFieldValue('stitch_sample', data.stitch_sample);
                setFieldValue('description', data.description);
                setFieldValue('category', data.category);
                setFieldValue('tags', data.tags);
                setFieldValue('comment', data.comment);
                setFieldValue('link', data.link);
                if (data.link) initialLink = data.link;

                // Set AI enhanced flag
                const isAiEnhanced = data.is_ai_enhanced === true;
                const hiddenAiInput = document.getElementById('is_ai_enhanced');
                if (hiddenAiInput) hiddenAiInput.value = isAiEnhanced ? '1' : '';
                const aiCheckbox = document.getElementById('is_ai_enhanced_checkbox');
                const aiCheckboxMobile = document.getElementById('is_ai_enhanced_mobile_checkbox');
                if (aiCheckbox) aiCheckbox.checked = isAiEnhanced;
                if (aiCheckboxMobile) aiCheckboxMobile.checked = isAiEnhanced;

                // Image URLs (Project level)
                const importImagesField = document.getElementById('import_image_urls');
                const imageUrls = Array.isArray(data.image_urls) ? data.image_urls : [];
                if (importImagesField) {
                    importImagesField.value = imageUrls.length ? JSON.stringify(imageUrls) : '';
                }
                const archiveField = document.getElementById('archive_on_save');
                if (archiveField) {
                    archiveField.value = '1';
                }

                // Render pending images for preview
                if (imageUrls.length > 0) {
                    imageUrls.forEach(url => {
                        if (typeof addPendingTitleImageToGallery === 'function') {
                            try { addPendingTitleImageToGallery(url); } catch (e) { console.error(e); }
                        }
                    });
                }

                // Steps
                if (data.steps && data.steps.length > 0) {
                    const stepsContainer = document.getElementById('stepsContainer');
                    if (stepsContainer) {
                        stepsContainer.innerHTML = '';
                        data.steps.forEach((step, index) => {
                            if (typeof addStep === 'function') {
                                try {
                                    addStep(step.title || `Step ${index + 1}`, step.description || '', step.images || []);
                                } catch (e) {
                                    console.error('Failed to add step from storage', e, step);
                                }
                            }
                        });
                    }
                }

                sessionStorage.removeItem('importedData');
                window.unsavedChanges?.setDirty(true);
                window.showToast?.('{{ _("Pattern data loaded - please review and save") }}', 'success');

                setTimeout(() => {
                    const saveButton = document.querySelector('button[type="submit"]');
                    if (saveButton) {
                        saveButton.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        saveButton.classList.add('ring-4', 'ring-primary', 'ring-opacity-50');
                        setTimeout(() => {
                            saveButton.classList.remove('ring-4', 'ring-primary', 'ring-opacity-50');
                        }, 3000);
                    }
                }, 500);

            } catch (error) {
                console.error('Error loading imported data:', error);
                sessionStorage.removeItem('importedData');
            }
        }

        document.querySelectorAll('textarea').forEach(el => {
            el.style.overflowY = 'hidden';
            autoResize(el);
            updateImageVisibility(el);
            el.addEventListener('input', () => {
                autoResize(el);
                updateImageVisibility(el);
            });

            setupTextareaDrop(el);
        });

        // Initialize checkbox states based on link presence
        const linkEl = document.getElementById('link');
        if (linkEl) syncLinkInputs(linkEl);

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('import') === '1') {
            const currentUrl = document.getElementById('link')?.value;
            if (currentUrl) {
                importFromUrl(currentUrl);
            } else {
                document.getElementById('importDialog')?.showModal();
            }
        }
    });

    function initTagEditor() {
        const hiddenInput = document.getElementById('tags');
        if (!hiddenInput) return;

        const desktop = {
            input: document.getElementById('tags_input'),
            chips: document.getElementById('tags_chips'),
            suggestions: document.getElementById('tags_suggestions'),
        };
        const mobile = {
            input: document.getElementById('tags_input_mobile'),
            chips: document.getElementById('tags_chips_mobile'),
            suggestions: document.getElementById('tags_suggestions_mobile'),
        };
        const views = [desktop, mobile].filter(view => view.input && view.chips);

        const normalizeTag = (raw) => raw.replace(/^#/, '').trim();
        const splitTags = (raw) => raw.split(/[,#\\s]+/).map(normalizeTag).filter(Boolean);

        const tags = [];
        const tagIndex = new Set();

        const addTag = (tag) => {
            const normalized = normalizeTag(tag);
            if (!normalized) return;
            const key = normalized.toLowerCase();
            if (tagIndex.has(key)) return;
            tagIndex.add(key);
            tags.push(normalized);
            renderChips();
            syncHidden();
        };

        const removeTag = (tag) => {
            const key = tag.toLowerCase();
            if (!tagIndex.has(key)) return;
            tagIndex.delete(key);
            const index = tags.findIndex(item => item.toLowerCase() === key);
            if (index >= 0) tags.splice(index, 1);
            renderChips();
            syncHidden();
        };

        const syncHidden = () => {
            hiddenInput.value = tags.join(', ');
        };

        const renderChips = () => {
            views.forEach(view => {
                view.chips.innerHTML = '';
                tags.forEach(tag => {
                    const chip = document.createElement('button');
                    chip.type = 'button';
                    chip.className = 'badge badge-outline gap-1';
                    chip.setAttribute('data-tag', tag);
                    chip.innerHTML = `#${tag}<span class="mdi mdi-close text-[10px]"></span>`;
                    chip.addEventListener('click', () => removeTag(tag));
                    view.chips.appendChild(chip);
                });
            });
            refreshSuggestions();
        };

        const refreshSuggestions = () => {
            const selected = new Set(tags.map(tag => tag.toLowerCase()));
            views.forEach(view => {
                if (!view.suggestions) return;
                view.suggestions.querySelectorAll('.tag-suggestion').forEach(button => {
                    const tag = button.dataset.tag || '';
                    const isHidden = selected.has(tag.toLowerCase());
                    button.classList.toggle('hidden', isHidden);
                });
            });
        };

        const addFromInput = (input) => {
            const raw = input.value;
            splitTags(raw).forEach(addTag);
            input.value = '';
            refreshSuggestions();
        };

        const handleInput = (event, view) => {
            if (!view.suggestions) return;
            const query = event.target.value.trim().toLowerCase();
            const hasQuery = query.length > 0;
            let anyVisible = false;
            view.suggestions.querySelectorAll('.tag-suggestion').forEach(button => {
                const tag = (button.dataset.tag || '').toLowerCase();
                const matches = !query || tag.includes(query);
                const isSelected = tagIndex.has(tag);
                const shouldShow = matches && !isSelected;
                button.classList.toggle('hidden', !shouldShow);
                if (shouldShow) anyVisible = true;
            });
            view.suggestions.classList.toggle('hidden', !hasQuery || !anyVisible);
        };

        const handleKeydown = (event, view) => {
            if (event.key === 'Enter' || event.key === 'Tab') {
                if (event.target.value.trim()) {
                    event.preventDefault();
                    addFromInput(event.target);
                    view.suggestions?.classList.add('hidden');
                }
            }
            if (event.key === 'Escape') {
                view.suggestions?.classList.add('hidden');
            }
        };

        const handleBlur = (view) => {
            setTimeout(() => {
                view.suggestions?.classList.add('hidden');
                if (view.input && view.input.value.trim()) {
                    addFromInput(view.input);
                }
            }, 100);
        };

        const bindView = (view) => {
            if (!view.input) return;
            view.input.addEventListener('input', (event) => handleInput(event, view));
            view.input.addEventListener('keydown', (event) => handleKeydown(event, view));
            view.input.addEventListener('blur', () => handleBlur(view));
            view.suggestions?.querySelectorAll('.tag-suggestion').forEach(button => {
                button.addEventListener('click', () => {
                    addTag(button.dataset.tag || '');
                    view.suggestions?.classList.add('hidden');
                });
            });
        };

        splitTags(hiddenInput.value).forEach(addTag);
        views.forEach(bindView);
        refreshSuggestions();
    }

    function initYarnSelector() {
        const searchInput = document.getElementById('yarn_search');
        const dropdown = document.getElementById('yarn_dropdown');
        const selectedContainer = document.getElementById('selected_yarns');
        const hiddenInput = document.getElementById('yarn_ids');
        const yarnOptions = document.querySelectorAll('.yarn-option');

        const selectedYarns = new Map();
        const pendingYarns = new Set(); // Yarns that don't exist in DB yet

        function selectYarn(id, name, brand, colorway, dyeLot, imageUrl) {
            if (selectedYarns.has(id)) return;

            selectedYarns.set(id, { name, brand, colorway, dyeLot, imageUrl });
            updateSelectedDisplay();
            updateHiddenInput();
            filterOptions();
        }

        function selectPendingYarn(name) {
            const normalized = name.trim();
            if (!normalized || pendingYarns.has(normalized)) return;
            
            // Check if it already exists in selectedYarns by name
            for (let y of selectedYarns.values()) {
                if (y.name.toLowerCase() === normalized.toLowerCase()) return;
            }

            pendingYarns.add(normalized);
            updateSelectedDisplay();
            updateHiddenInput();
        }

        function removeYarn(id) {
            selectedYarns.delete(id);
            updateSelectedDisplay();
            updateHiddenInput();
            filterOptions();
        }

        function removePendingYarn(name) {
            pendingYarns.delete(name);
            updateSelectedDisplay();
            updateHiddenInput();
        }

        // Expose API
        window.yarnSelector = {
            select: selectYarn,
            remove: removeYarn,
            selectByName: function (name) {
                if (!name) return { anySelected: false, remaining: '' };
                
                let rawNames = [];
                if (name.includes('\n')) {
                    rawNames = name.split('\n').map(n => n.trim()).filter(Boolean);
                } else {
                    // Smart comma splitting: avoid splitting on commas followed by color names
                    // or preceded by "Farbe/color" specs (Garnstudio style).
                    if (/(?:farbe|color|colour)\s*\d+\s*,\s*/i.test(name)) {
                        rawNames = [name.trim()];
                    } else {
                        rawNames = name.split(',').map(n => n.trim()).filter(Boolean);
                    }
                }
                const names = rawNames;
                let anySelected = false;

                names.forEach(n => {
                    const nLower = n.toLowerCase();
                    const option = Array.from(yarnOptions).find(opt => {
                        const optName = opt.dataset.yarnName.toLowerCase();
                        const optBrand = (opt.dataset.yarnBrand || '').toLowerCase();
                        return optName === nLower ||
                            `${optBrand} ${optName}`.toLowerCase() === nLower ||
                            (optBrand && nLower.includes(optBrand) && nLower.includes(optName));
                    });

                    if (option) {
                        selectYarn(
                            parseInt(option.dataset.yarnId),
                            option.dataset.yarnName,
                            option.dataset.yarnBrand,
                            option.dataset.yarnColorway,
                            option.dataset.yarnDyeLot,
                            option.dataset.yarnImage
                        );
                        anySelected = true;
                    } else {
                        selectPendingYarn(n);
                        anySelected = true;
                    }
                });

                // Clear the visible search input
                if (searchInput) {
                    searchInput.value = '';
                }

                return { anySelected, remaining: '' };
            }
        };

        {% if project and project.yarn_ids %}
        const preSelectedIds = {{ project.yarn_ids | tojson }};
        yarnOptions.forEach(option => {
            const yarnId = parseInt(option.dataset.yarnId);
            if (preSelectedIds.includes(yarnId)) {
                selectYarn(
                    yarnId,
                    option.dataset.yarnName,
                    option.dataset.yarnBrand,
                    option.dataset.yarnColorway,
                    option.dataset.yarnDyeLot,
                    option.dataset.yarnImage,
                );
            }
        });
        {% endif %}

        function updateSelectedDisplay() {
            if (selectedYarns.size === 0 && pendingYarns.size === 0) {
                selectedContainer.innerHTML = '<span class="text-base-content/40 text-sm">{{ _("No yarns selected") }}</span>';
                return;
            }

            selectedContainer.innerHTML = '';
            
            // Render existing yarns
            selectedYarns.forEach((yarn, id) => {
                const chip = document.createElement('div');
                chip.className = 'flex items-center gap-2 py-2 px-3 bg-primary/10 text-primary border border-primary/20 rounded-lg';

                const imageHtml = yarn.imageUrl
                    ? `<img src="${yarn.imageUrl}" alt="${yarn.name}" class="w-8 h-8 rounded object-cover" onerror="this.replaceWith(this.parentElement.querySelector('[data-fallback-icon]').cloneNode(true)); this.parentElement.querySelector('[data-fallback-icon]').classList.remove('hidden')">`
                    : '';

                chip.innerHTML = `
                    ${imageHtml}
                    <div class="w-8 h-8 rounded bg-base-300 flex items-center justify-center text-base-content/60${yarn.imageUrl ? ' hidden' : ''}" data-fallback-icon>
                        <span class="mdi mdi-image-off text-sm" aria-hidden="true"></span>
                    </div>
                    <span class="text-sm flex-1">
                        ${yarn.name}${yarn.brand ? ` â€¢ ${yarn.brand}` : ''}
                    </span>
                    <button type="button" class="btn btn-ghost btn-xs btn-circle" data-remove-yarn="${id}">
                        <span class="mdi mdi-close"></span>
                    </button>
                `;
                selectedContainer.appendChild(chip);

                chip.querySelector('[data-remove-yarn]').addEventListener('click', () => {
                    removeYarn(id);
                });
            });

            // Render pending yarns
            pendingYarns.forEach(name => {
                const chip = document.createElement('div');
                chip.className = 'flex items-center gap-2 py-2 px-3 bg-secondary/10 text-secondary border border-secondary/20 rounded-lg';

                chip.innerHTML = `
                    <div class="relative w-8 h-8 rounded bg-base-300 flex items-center justify-center text-base-content/60">
                        <span class="mdi mdi-sheep text-sm" aria-hidden="true"></span>
                        <span class="absolute -top-1.5 -right-1.5 badge badge-secondary font-black text-[8px] h-3 min-h-0 px-1 border-none shadow-sm scale-90">NEW</span>
                    </div>
                    <div class="flex-1 min-w-0">
                        <span class="text-sm block truncate">${name}</span>
                    </div>
                    <button type="button" class="btn btn-ghost btn-xs btn-circle" data-remove-pending="${name}">
                        <span class="mdi mdi-close"></span>
                    </button>
                `;
                selectedContainer.appendChild(chip);

                chip.querySelector('[data-remove-pending]').addEventListener('click', () => {
                    removePendingYarn(name);
                });
            });
        }

        function updateHiddenInput() {
            hiddenInput.value = Array.from(selectedYarns.keys()).join(',');
            
            const yarnTextHidden = document.getElementById('yarn_text_hidden');
            if (yarnTextHidden) {
                yarnTextHidden.value = Array.from(pendingYarns).join('\n');
            }
            
            // Explicitly clear yarn_search if we have pending yarns as chips
            const searchInput = document.getElementById('yarn_search');
            if (searchInput && pendingYarns.size > 0 && document.activeElement !== searchInput) {
                // If the user isn't typing, make sure it's clean
                if (searchInput.value.includes('\n') || Array.from(pendingYarns).some(y => searchInput.value.includes(y))) {
                    searchInput.value = '';
                }
            }
        }

    function filterOptions() {
        const searchTerm = searchInput.value.toLowerCase();
        let visibleCount = 0;

        yarnOptions.forEach(option => {
            const yarnId = parseInt(option.dataset.yarnId);
            const isSelected = selectedYarns.has(yarnId);
            const name = option.dataset.yarnName.toLowerCase();
            const brand = (option.dataset.yarnBrand || '').toLowerCase();
            const colorway = (option.dataset.yarnColorway || '').toLowerCase();
            const dyeLot = (option.dataset.yarnDyeLot || '').toLowerCase();
            const matchesSearch =
                !searchTerm
                || name.includes(searchTerm)
                || brand.includes(searchTerm)
                || colorway.includes(searchTerm)
                || dyeLot.includes(searchTerm);

            if (!isSelected && matchesSearch) {
                option.classList.remove('hidden');
                visibleCount++;
            } else {
                option.classList.add('hidden');
            }
        });

        if (visibleCount > 0 && (searchInput === document.activeElement || searchTerm)) {
            dropdown.classList.remove('hidden');
        } else {
            dropdown.classList.add('hidden');
        }
    }

    searchInput.addEventListener('focus', () => {
        filterOptions();
    });

    searchInput.addEventListener('input', () => {
        filterOptions();
    });

    searchInput.addEventListener('blur', (e) => {
        setTimeout(() => {
            if (!dropdown.contains(document.activeElement)) {
                dropdown.classList.add('hidden');
            }
        }, 200);
    });

    yarnOptions.forEach(option => {
        option.addEventListener('click', (e) => {
            e.preventDefault();
            const yarnId = parseInt(option.dataset.yarnId);
            const yarnName = option.dataset.yarnName;
            const yarnBrand = option.dataset.yarnBrand;
            const yarnColorway = option.dataset.yarnColorway;
            const yarnDyeLot = option.dataset.yarnDyeLot;
            const yarnImage = option.dataset.yarnImage;

            selectYarn(yarnId, yarnName, yarnBrand, yarnColorway, yarnDyeLot, yarnImage);
            searchInput.value = '';
            searchInput.focus();
        });
    });

    document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
            dropdown.classList.add('hidden');
        }
    });
}

    function setupTextareaDrop(textarea) {
        textarea.addEventListener('dragover', (e) => {
            e.preventDefault();
            textarea.classList.add('border-blue-500', 'ring-2', 'ring-blue-500');
        });

        textarea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            textarea.classList.remove('border-blue-500', 'ring-2', 'ring-blue-500');
        });

        textarea.addEventListener('drop', async (e) => {
            e.preventDefault();
            textarea.classList.remove('border-blue-500', 'ring-2', 'ring-blue-500');

            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                if (imageFiles.length === 0) return;

                const stepItem = textarea.closest('.step-item');
                let sid = stepItem ? stepItem.getAttribute('data-step-id') : null;

                if (stepItem && !sid) {
                    sid = await ensureStepId(stepItem);
                    if (!sid) return;
                }

                if (!sid && !projectId) {
                    if (!(await ensureProjectId())) return;
                }

                for (const file of imageFiles) {
                    await uploadAndInsertImage(file, textarea, sid);
                }
                return;
            }

            const text = e.dataTransfer.getData('text/plain');
            if (text) {
                insertAtCursor(textarea, text);
            }
        });
    }

    function handleImageDragStart(event) {
        // Find the anchor element (either target itself or parent)
        const anchor = event.target.tagName === 'A' ? event.target : event.target.closest('a');
        if (!anchor) return;

        const src = anchor.getAttribute('href');
        const alt = anchor.getAttribute('data-pswp-caption') || (anchor.querySelector('img')?.alt) || "";
        const markdown = `![${alt}](${src})`;

        // Debug
        console.log('Dragging image as markdown:', markdown);

        // Set data
        event.dataTransfer.setData('text/plain', markdown);
        event.dataTransfer.effectAllowed = 'copy';

        // Important: set dropEffect in dragover/drop handlers, here we just set effectAllowed
    }
    function insertAtCursor(textarea, text) {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const val = textarea.value;
        textarea.value = val.substring(0, start) + text + val.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + text.length;
        textarea.focus();
        textarea.dispatchEvent(new Event('input', { bubbles: true }));
        autoResize(textarea);
    }
    /**
     * Helper to create a unified image preview card in JavaScript.
     * Matches the image_preview Jinja macro.
     */
    function createImagePreviewHTML(imageData, options = {}) {
        const {
            showPromote = false,
            showDelete = true,
            isPrimary = false,
            projectId = window.projectId,
            imageClass = 'h-32'
        } = options;

        const pswpWidth = imageData.width || 1200;
        const pswpHeight = imageData.height || 1200;
        const altText = imageData.alt_text || "";
        const thumbUrl = imageData.thumbnail_url || imageData.url;

        return `
        <div class="relative group" data-image-id="${imageData.id}">
            <a href="${imageData.url}" 
               data-pswp-width="${pswpWidth}"
               data-pswp-height="${pswpHeight}" 
               data-pswp-caption="${altText}" 
               ${showPromote ? 'data-pswp-promote="true"' : ''}
               ${showDelete ? 'data-pswp-delete="true"' : ''}
               data-pswp-is-primary="${isPrimary ? 'true' : 'false'}"
               draggable="true" ondragstart="handleImageDragStart(event)"
               class="block">
                <img src="${thumbUrl}" 
                     alt="${altText}" 
                     class="${imageClass} w-full cursor-zoom-in rounded object-cover shadow dark:shadow-slate-900/30">
            </a>
            ${showPromote ? `
            <button type="button" onclick="promoteImage(${projectId}, ${imageData.id})"
                class="title-promote-btn absolute top-1 left-1 z-10 rounded-full p-1 shadow-sm transition-all ${isPrimary ? 'bg-amber-400 text-white opacity-100' : 'bg-white/90 text-slate-400 opacity-0 group-hover:opacity-100 dark:bg-slate-900/90 dark:text-slate-500'} hover:bg-amber-50 hover:text-amber-600 dark:hover:bg-amber-900/50 dark:hover:text-amber-400"
                title="{{ _('Make title image') }}">
                <span class="mdi ${isPrimary ? 'mdi-star' : 'mdi-star-outline'}"></span>
            </button>
            ` : ''}
            ${showDelete ? `
            <button type="button" onclick="deleteImage(${imageData.id})"
                class="absolute top-1 right-1 z-10 bg-red-600 text-white rounded-full p-1 hover:bg-red-700 dark:hover:bg-red-500 shadow-sm opacity-0 group-hover:opacity-100 transition-opacity">
                <span class="mdi mdi-delete"></span>
            </button>
            ` : ''}
        </div>
        `;
    }

    async function uploadAndInsertImage(file, textarea, stepId) {
        if (!stepId && !(await ensureProjectId())) return;

        const formData = new FormData();
        formData.append('file', file);
        formData.append('alt_text', file.name);

        const url = stepId
            ? `/projects/${projectId}/steps/${stepId}/images` 
            : `/projects/${projectId}/images/title`;

        try {
            window.showToast?.('{{ _("Uploading image...") }}', 'info');
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'X-CSRF-Token': '{{ csrf_token }}'
                },
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                const markdown = `![${data.alt_text}](${data.url})`;
                insertAtCursor(textarea, markdown);
                window.showToast?.('{{ _("Image uploaded!") }}', 'success');
                window.unsavedChanges?.setDirty(true);

                if (stepId) {
                    const stepItem = document.querySelector(`.step-item[data-step-id="${stepId}"]`);
                    if (stepItem) {
                        addStepImagePreview(stepItem, data);
                    }
                } else {
                    addTitleImageToGallery(data);
                }
            } else {
                window.showToast?.('{{ _("Upload failed") }}', 'error');
            }
        } catch (error) {
            console.error('Upload failed', error);
            window.showToast?.('{{ _("Upload failed") }}', 'error');
        }
    }
</script>

<script>
    let projectId = {{ (project.id if project else none) | tojson }};
    let wasSilentlyCreated = false;

    // Initialize discard hook
    document.addEventListener('DOMContentLoaded', () => {
        if (window.unsavedChanges) {
            window.unsavedChanges.onBeforeDiscard = async () => {
                if (wasSilentlyCreated && projectId) {
                    console.log('Discarding silent project:', projectId);
                    try {
                        const response = await fetch(`/projects/${projectId}`, {
                            method: 'DELETE',
                            headers: {
                                'HX-Request': 'true', // Trigger HTMX-like response if needed, although we are navigating away
                                'X-CSRF-Token': '{{ csrf_token }}'
                            }
                        });
                        if (!response.ok) {
                            console.error('Failed to delete silent project');
                        }
                    } catch (error) {
                        console.error('Error deleting silent project:', error);
                    }
                }
            };
        }
    });

    /**
     * Ensures the project exists before performing actions that require a projectId.
     * If project doesn't exist, it performs a minimal save to get an ID.
     */
    async function ensureProjectId() {
        if (projectId) return true;

        const nameInput = document.getElementById('name');
        if (nameInput && !nameInput.value.trim()) {
            const now = new Date();
            const dateStr = now.getFullYear() + '-' +
                String(now.getMonth() + 1).padStart(2, '0') + '-' +
                String(now.getDate()).padStart(2, '0');
            nameInput.value = `{{ _("New Project") }} ${dateStr}`;
        }

        const formData = new FormData(document.getElementById('projectForm'));

        try {
            const response = await fetch('/projects', {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'X-CSRF-Token': '{{ csrf_token }}'
                },
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                projectId = data.id;
                wasSilentlyCreated = true;
                window.unsavedChanges?.setDirty(true);

                // Update form action and other links
                const form = document.getElementById('projectForm');
                if (form) {
                    form.action = `/projects/${projectId}`;
                }

                // Update back button link
                const backBtn = document.querySelector('[data-unsaved-confirm]');
                if (backBtn && backBtn.tagName.toLowerCase() === 'a') {
                    backBtn.href = '/projects';
                }

                // Update browser URL without reloading
                window.history.replaceState({}, '', `/projects/${projectId}/edit`);
                return true;
            } else {
                window.showToast?.('{{ _("Failed to initialize project") }}', 'error');
                return false;
            }
        } catch (error) {
            console.error('Project initialization failed', error);
            window.showToast?.('{{ _("Network error") }}', 'error');
            return false;
        }
    }

    const uploadInstructionsText = '{{ _("Drag and drop images here or click to upload") }}';
    const stepUploadDisabledMessage = '{{ _("Save the project before adding images to this step") }}';
    const uploadErrorMessage = '{{ _("Image upload failed. Please try again") }}';
    const uploadNetworkErrorMessage = '{{ _("Network error while uploading image") }}';
    const unsupportedFileMessage = '{{ _("Only image files are supported") }}';
    const deleteErrorMessage = '{{ _("Failed to delete the image. Please try again") }}';
    const deleteNetworkErrorMessage = '{{ _("Network error while deleting image") }}';
    const uploadingMessage = '{{ _("Uploadingâ€¦") }}';

    const parseErrorMessage =
        typeof extractErrorMessage === 'function'
            ? extractErrorMessage
            : async (_response, fallback) => fallback;

    function bindPendingStepDropzone(dropzone, input, instructions) {
        if (!dropzone || dropzone.dataset.pendingBound === 'true') {
            return;
        }

        dropzone.dataset.pendingBound = 'true';
        dropzone.classList.add('opacity-60', 'cursor-not-allowed');
        dropzone.classList.remove('pointer-events-none');
        dropzone.setAttribute('aria-disabled', 'true');

        if (instructions) {
            instructions.textContent =
                instructions.dataset.disabledText || stepUploadDisabledMessage;
        }

        const showDisabledToast = () => {
            window.showToast?.(stepUploadDisabledMessage, 'info');
        };

        dropzone.addEventListener('click', (event) => {
            event.preventDefault();
            showDisabledToast();
        });

        ['dragover', 'drop'].forEach((eventName) => {
            dropzone.addEventListener(eventName, (event) => {
                event.preventDefault();
                event.stopPropagation();
                if (eventName === 'dragover') {
                    dropzone.classList.add('border-blue-500');
                } else {
                    dropzone.classList.remove('border-blue-500');
                    showDisabledToast();
                }
            });
        });

        dropzone.addEventListener('dragleave', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropzone.classList.remove('border-blue-500');
        });

        const label = dropzone.querySelector('label');
        if (label) {
            ['click', 'dragover', 'drop', 'dragleave'].forEach((eventName) => {
                label.addEventListener(eventName, (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    if (eventName === 'dragover') {
                        dropzone.classList.add('border-blue-500');
                        return;
                    }

                    if (eventName === 'dragleave') {
                        dropzone.classList.remove('border-blue-500');
                        return;
                    }

                    if (eventName === 'drop') {
                        dropzone.classList.remove('border-blue-500');
                    }

                    showDisabledToast();
                });
            });
        }

        input.addEventListener('change', (event) => {
            event.preventDefault();
            input.value = '';
            showDisabledToast();
        });
    }

    async function uploadStepImage(stepId, file) {
        const formData = new FormData();
        formData.append('file', file);
        formData.append('alt_text', file.name);

        let response;
        try {
            response = await fetch(`/projects/${projectId}/steps/${stepId}/images`, {
                method: 'POST',
                headers: {
                    'X-CSRF-Token': '{{ csrf_token }}'
                },
                body: formData,
            });
        } catch (error) {
            console.error('Step image upload failed', error);
            window.showToast?.(uploadNetworkErrorMessage, 'error');
            return null;
        }

        if (!response.ok) {
            const message = await parseErrorMessage(response, uploadErrorMessage);
            window.showToast?.(message, 'error');
            return null;
        }

        const data = await response.json();
        window.unsavedChanges?.setDirty(true);
        return data;
    }

    function addStepImagePreview(stepItem, imageData) {
        const imagesContainer = stepItem.querySelector('.step-images');
        if (!imagesContainer) return;

        imagesContainer.insertAdjacentHTML('beforeend', createImagePreviewHTML(imageData, {
            imageClass: 'h-20'
        }));
        window.refreshPhotoSwipeGallery?.(imagesContainer);
        const textarea = stepItem.querySelector('.step-description');
        if (textarea) updateImageVisibility(textarea);
    }

    function initStepImageUploaders() {
        document.querySelectorAll('.step-item').forEach((stepItem) => {
            const dropzone = stepItem.querySelector('.step-image-dropzone');
            const input = stepItem.querySelector('.step-image-input');
            const instructions = dropzone?.querySelector('.upload-instructions');
            const stepId = stepItem.getAttribute('data-step-id');

            if (!dropzone || !input || dropzone.dataset.initialized === 'true') {
                return;
            }

            dropzone.classList.remove(
                'opacity-60',
                'opacity-50',
                'cursor-not-allowed',
                'pointer-events-none',
            );
            dropzone.removeAttribute('aria-disabled');
            if (instructions) {
                instructions.textContent = instructions.dataset.enabledText || uploadInstructionsText;
            }

            window.setupImageUploadWidget(input, dropzone, async (file) => {
                const sid = await ensureStepId(stepItem);
                if (sid) {
                    const data = await uploadStepImage(sid, file);
                    if (data) {
                        addStepImagePreview(stepItem, data);
                    }
                }
            });
        });
    }

    async function ensureStepId(stepItem) {
        if (!(await ensureProjectId())) return null;
        let stepId = stepItem.getAttribute('data-step-id');
        if (stepId) return stepId;

        return await saveStepInternal(stepItem);
    }

    async function saveStepInternal(stepItem) {
        const stepId = stepItem.getAttribute('data-step-id');
        const title = stepItem.querySelector('.step-title').value;
        const description = stepItem.querySelector('.step-description').value;
        const stepNumber = parseInt(stepItem.getAttribute('data-step-number')) || 1;

        if (!(await ensureProjectId())) return null;

        try {
            const url = stepId
                ? `/projects/${projectId}/steps/${stepId}`
                : `/projects/${projectId}/steps`;
            const method = stepId ? 'PUT' : 'POST';

            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-Token': '{{ csrf_token }}'
                },
                body: JSON.stringify({
                    title: title,
                    description: description,
                    step_number: stepNumber
                })
            });

            if (!response.ok) {
                throw new Error('Failed to save step');
            }

            const data = await response.json();

            if (!stepId && data.id) {
                stepItem.setAttribute('data-step-id', data.id);
                const dropzone = stepItem.querySelector('.step-image-dropzone');
                const fileInput = stepItem.querySelector('.step-image-input');
                if (dropzone) dropzone.setAttribute('data-step-id', data.id);
                if (fileInput) fileInput.setAttribute('data-step-id', data.id);

                // Re-initialize the newly saved step's uploader
                initStepImageUploaders();
            }

            window.showToast?.('{{ _("Step saved successfully") }}', 'success');
            window.unsavedChanges?.setDirty(true);
            return data.id;
        } catch (error) {
            console.error('Save step failed', error);
            window.showToast?.('{{ _("Failed to save step") }}', 'error');
            return null;
        }
    }

    function initStitchSampleImageUploader() {
        const dropzone = document.getElementById('stitchSampleDropzone');
        const input = document.getElementById('stitchSampleImageInput');

        if (!dropzone || !input || dropzone.dataset.initialized === 'true') {
            return;
        }

        window.setupImageUploadWidget(input, dropzone, async (file) => {
            if (!(await ensureProjectId())) return;

            const formData = new FormData();
            formData.append('file', file);
            formData.append('alt_text', file.name);

            try {
                const response = await fetch(`/projects/${projectId}/images/stitch-sample`, {
                    method: 'POST',
                    headers: {
                        'X-CSRF-Token': '{{ csrf_token }}'
                    },
                    body: formData,
                });

                if (!response.ok) {
                    const message = await parseErrorMessage(response, uploadErrorMessage);
                    window.showToast?.(message, 'error');
                    return;
                }

                const data = await response.json();
                addStitchSampleImagePreview(data);
                window.unsavedChanges?.setDirty(true);
            } catch (error) {
                console.error('Stitch sample image upload failed', error);
                window.showToast?.(uploadNetworkErrorMessage, 'error');
            }
        });
    }

    function addStitchSampleImagePreview(imageData) {
        const container = document.getElementById('stitchSampleImagesContainer');
        if (!container) return;

        container.insertAdjacentHTML('beforeend', createImagePreviewHTML(imageData));
        if (window.refreshPhotoSwipeGallery) {
            window.refreshPhotoSwipeGallery(container);
        }
        const textarea = document.getElementById('stitch_sample');
        if (textarea) updateImageVisibility(textarea);
    }

    initStepImageUploaders();
    initStitchSampleImageUploader();

    document.addEventListener('DOMContentLoaded', () => {
        const titleImageInput = document.getElementById('titleImageInput');
        const titleImageDropZone = document.getElementById('titleImageDropZone');
        if (titleImageInput && titleImageDropZone) {
            window.setupImageUploadWidget(titleImageInput, titleImageDropZone, uploadTitleImage);
        }

        initYarnSelector();
        initTagEditor();

        const importedData = sessionStorage.getItem('importedData');
        if (importedData) {
            try {
                const data = JSON.parse(importedData);
                console.log('[DEBUG] Loading imported data from storage:', data);

                // Prevent re-prompting on save
                isImportPrompted = true;

                const setFieldValue = (id, value) => {
                    const el = document.getElementById(id);
                    if (el && value !== undefined && value !== null) {
                        if (id === 'comment' && el.value.trim().length > 0) return false;
                        el.value = value;
                        if (typeof autoResize === 'function') autoResize(el);
                        return true;
                    }
                    return false;
                };

                const warningBanner = document.getElementById('importWarning');
                if (warningBanner) warningBanner.classList.remove('hidden');

                // Metadata
                setFieldValue('name', data.title || data.name);
                setFieldValue('needles', data.needles);
                setFieldValue('recommended_needles', data.recommended_needles);
                setFieldValue('yarn_brand', data.brand);
                
                const yarnDetailsField = document.getElementById('yarn_details');
                if (yarnDetailsField && data.yarn_details) {
                    yarnDetailsField.value = JSON.stringify(data.yarn_details);
                }

                if (data.yarn) {
                    window.yarnSelector?.selectByName(data.yarn);
                }

                setFieldValue('gauge_stitches', data.gauge_stitches);
                setFieldValue('gauge_rows', data.gauge_rows);
                setFieldValue('stitch_sample', data.stitch_sample);
                setFieldValue('description', data.description);
                setFieldValue('category', data.category);
                setFieldValue('tags', data.tags);
                setFieldValue('comment', data.comment);
                setFieldValue('link', data.link);
                if (data.link) initialLink = data.link;

                // Set AI enhanced flag
                const isAiEnhanced = data.is_ai_enhanced === true;
                const hiddenAiInput = document.getElementById('is_ai_enhanced');
                if (hiddenAiInput) hiddenAiInput.value = isAiEnhanced ? '1' : '';
                const aiCheckbox = document.getElementById('is_ai_enhanced_checkbox');
                const aiCheckboxMobile = document.getElementById('is_ai_enhanced_mobile_checkbox');
                if (aiCheckbox) aiCheckbox.checked = isAiEnhanced;
                if (aiCheckboxMobile) aiCheckboxMobile.checked = isAiEnhanced;

                // Image URLs (Project level)
                const importImagesField = document.getElementById('import_image_urls');
                const imageUrls = Array.isArray(data.image_urls) ? data.image_urls : [];
                if (importImagesField) {
                    importImagesField.value = imageUrls.length ? JSON.stringify(imageUrls) : '';
                }
                const archiveField = document.getElementById('archive_on_save');
                if (archiveField) {
                    archiveField.value = '1';
                }

                // Render pending images for preview
                if (imageUrls.length > 0) {
                    imageUrls.forEach(url => {
                        if (typeof addPendingTitleImageToGallery === 'function') {
                            try { addPendingTitleImageToGallery(url); } catch (e) { console.error(e); }
                        }
                    });
                }

                // Steps
                if (data.steps && data.steps.length > 0) {
                    const stepsContainer = document.getElementById('stepsContainer');
                    if (stepsContainer) {
                        stepsContainer.innerHTML = '';
                        data.steps.forEach((step, index) => {
                            if (typeof addStep === 'function') {
                                try {
                                    addStep(step.title || `Step ${index + 1}`, step.description || '', step.images || []);
                                } catch (e) {
                                    console.error('Failed to add step from storage', e, step);
                                }
                            }
                        });
                    }
                }

                sessionStorage.removeItem('importedData');
                window.unsavedChanges?.setDirty(true);
                window.showToast?.('{{ _("Pattern data loaded - please review and save") }}', 'success');

                setTimeout(() => {
                    const saveButton = document.querySelector('button[type="submit"]');
                    if (saveButton) {
                        saveButton.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        saveButton.classList.add('ring-4', 'ring-primary', 'ring-opacity-50');
                        setTimeout(() => {
                            saveButton.classList.remove('ring-4', 'ring-primary', 'ring-opacity-50');
                        }, 3000);
                    }
                }, 500);

            } catch (error) {
                console.error('Error loading imported data:', error);
                sessionStorage.removeItem('importedData');
            }
        }

        document.querySelectorAll('textarea').forEach(el => {
            el.style.overflowY = 'hidden';
            autoResize(el);
            updateImageVisibility(el);
            el.addEventListener('input', () => {
                autoResize(el);
                updateImageVisibility(el);
            });

            setupTextareaDrop(el);
        });

        // Initialize checkbox states based on link presence
        const linkEl = document.getElementById('link');
        if (linkEl) syncLinkInputs(linkEl);

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('import') === '1') {
            const currentUrl = document.getElementById('link')?.value;
            if (currentUrl) {
                importFromUrl(currentUrl);
            } else {
                document.getElementById('importDialog')?.showModal();
            }
        }
    });

    function initTagEditor() {
        const hiddenInput = document.getElementById('tags');
        if (!hiddenInput) return;

        const desktop = {
            input: document.getElementById('tags_input'),
            chips: document.getElementById('tags_chips'),
            suggestions: document.getElementById('tags_suggestions'),
        };
        const mobile = {
            input: document.getElementById('tags_input_mobile'),
            chips: document.getElementById('tags_chips_mobile'),
            suggestions: document.getElementById('tags_suggestions_mobile'),
        };
        const views = [desktop, mobile].filter(view => view.input && view.chips);

        const normalizeTag = (raw) => raw.replace(/^#/, '').trim();
        const splitTags = (raw) => raw.split(/[,#\\s]+/).map(normalizeTag).filter(Boolean);

        const tags = [];
        const tagIndex = new Set();

        const addTag = (tag) => {
            const normalized = normalizeTag(tag);
            if (!normalized) return;
            const key = normalized.toLowerCase();
            if (tagIndex.has(key)) return;
            tagIndex.add(key);
            tags.push(normalized);
            renderChips();
            syncHidden();
        };

        const removeTag = (tag) => {
            const key = tag.toLowerCase();
            if (!tagIndex.has(key)) return;
            tagIndex.delete(key);
            const index = tags.findIndex(item => item.toLowerCase() === key);
            if (index >= 0) tags.splice(index, 1);
            renderChips();
            syncHidden();
        };

        const syncHidden = () => {
            hiddenInput.value = tags.join(', ');
        };

        const renderChips = () => {
            views.forEach(view => {
                view.chips.innerHTML = '';
                tags.forEach(tag => {
                    const chip = document.createElement('button');
                    chip.type = 'button';
                    chip.className = 'badge badge-outline gap-1';
                    chip.setAttribute('data-tag', tag);
                    chip.innerHTML = `#${tag}<span class="mdi mdi-close text-[10px]"></span>`;
                    chip.addEventListener('click', () => removeTag(tag));
                    view.chips.appendChild(chip);
                });
            });
            refreshSuggestions();
        };

        const refreshSuggestions = () => {
            const selected = new Set(tags.map(tag => tag.toLowerCase()));
            views.forEach(view => {
                if (!view.suggestions) return;
                view.suggestions.querySelectorAll('.tag-suggestion').forEach(button => {
                    const tag = button.dataset.tag || '';
                    const isHidden = selected.has(tag.toLowerCase());
                    button.classList.toggle('hidden', isHidden);
                });
            });
        };

        const addFromInput = (input) => {
            const raw = input.value;
            splitTags(raw).forEach(addTag);
            input.value = '';
            refreshSuggestions();
        };

        const handleInput = (event, view) => {
            if (!view.suggestions) return;
            const query = event.target.value.trim().toLowerCase();
            const hasQuery = query.length > 0;
            let anyVisible = false;
            view.suggestions.querySelectorAll('.tag-suggestion').forEach(button => {
                const tag = (button.dataset.tag || '').toLowerCase();
                const matches = !query || tag.includes(query);
                const isSelected = tagIndex.has(tag);
                const shouldShow = matches && !isSelected;
                button.classList.toggle('hidden', !shouldShow);
                if (shouldShow) anyVisible = true;
            });
            view.suggestions.classList.toggle('hidden', !hasQuery || !anyVisible);
        };

        const handleKeydown = (event, view) => {
            if (event.key === 'Enter' || event.key === 'Tab') {
                if (event.target.value.trim()) {
                    event.preventDefault();
                    addFromInput(event.target);
                    view.suggestions?.classList.add('hidden');
                }
            }
            if (event.key === 'Escape') {
                view.suggestions?.classList.add('hidden');
            }
        };

        const handleBlur = (view) => {
            setTimeout(() => {
                view.suggestions?.classList.add('hidden');
                if (view.input && view.input.value.trim()) {
                    addFromInput(view.input);
                }
            }, 100);
        };

        const bindView = (view) => {
            if (!view.input) return;
            view.input.addEventListener('input', (event) => handleInput(event, view));
            view.input.addEventListener('keydown', (event) => handleKeydown(event, view));
            view.input.addEventListener('blur', () => handleBlur(view));
            view.suggestions?.querySelectorAll('.tag-suggestion').forEach(button => {
                button.addEventListener('click', () => {
                    addTag(button.dataset.tag || '');
                    view.suggestions?.classList.add('hidden');
                });
            });
        };

        splitTags(hiddenInput.value).forEach(addTag);
        views.forEach(bindView);
        refreshSuggestions();
    }

    function initYarnSelector() {
        const searchInput = document.getElementById('yarn_search');
        const dropdown = document.getElementById('yarn_dropdown');
        const selectedContainer = document.getElementById('selected_yarns');
        const hiddenInput = document.getElementById('yarn_ids');
        const yarnOptions = document.querySelectorAll('.yarn-option');

        const selectedYarns = new Map();
        const pendingYarns = new Set(); // Yarns that don't exist in DB yet

        function selectYarn(id, name, brand, colorway, dyeLot, imageUrl) {
            if (selectedYarns.has(id)) return;

            selectedYarns.set(id, { name, brand, colorway, dyeLot, imageUrl });
            updateSelectedDisplay();
            updateHiddenInput();
            filterOptions();
        }

        function selectPendingYarn(name) {
            const normalized = name.trim();
            if (!normalized || pendingYarns.has(normalized)) return;
            
            // Check if it already exists in selectedYarns by name
            for (let y of selectedYarns.values()) {
                if (y.name.toLowerCase() === normalized.toLowerCase()) return;
            }

            pendingYarns.add(normalized);
            updateSelectedDisplay();
            updateHiddenInput();
        }

        function removeYarn(id) {
            selectedYarns.delete(id);
            updateSelectedDisplay();
            updateHiddenInput();
            filterOptions();
        }

        function removePendingYarn(name) {
            pendingYarns.delete(name);
            updateSelectedDisplay();
            updateHiddenInput();
        }

        // Expose API
        window.yarnSelector = {
            select: selectYarn,
            remove: removeYarn,
            selectByName: function (name) {
                if (!name) return { anySelected: false, remaining: '' };
                
                let rawNames = [];
                if (name.includes('\n')) {
                    rawNames = name.split('\n').map(n => n.trim()).filter(Boolean);
                } else {
                    // Smart comma splitting: avoid splitting on commas followed by color names
                    // or preceded by "Farbe/color" specs (Garnstudio style).
                    if (/(?:farbe|color|colour)\s*\d+\s*,\s*/i.test(name)) {
                        rawNames = [name.trim()];
                    } else {
                        rawNames = name.split(',').map(n => n.trim()).filter(Boolean);
                    }
                }
                const names = rawNames;
                let anySelected = false;

                names.forEach(n => {
                    const nLower = n.toLowerCase();
                    const option = Array.from(yarnOptions).find(opt => {
                        const optName = opt.dataset.yarnName.toLowerCase();
                        const optBrand = (opt.dataset.yarnBrand || '').toLowerCase();
                        return optName === nLower ||
                            `${optBrand} ${optName}`.toLowerCase() === nLower ||
                            (optBrand && nLower.includes(optBrand) && nLower.includes(optName));
                    });

                    if (option) {
                        selectYarn(
                            parseInt(option.dataset.yarnId),
                            option.dataset.yarnName,
                            option.dataset.yarnBrand,
                            option.dataset.yarnColorway,
                            option.dataset.yarnDyeLot,
                            option.dataset.yarnImage
                        );
                        anySelected = true;
                    } else {
                        selectPendingYarn(n);
                        anySelected = true;
                    }
                });

                // Clear the visible search input
                if (searchInput) {
                    searchInput.value = '';
                }

                return { anySelected, remaining: '' };
            }
        };

        {% if project and project.yarn_ids %}
        const preSelectedIds = {{ project.yarn_ids | tojson }};
        yarnOptions.forEach(option => {
            const yarnId = parseInt(option.dataset.yarnId);
            if (preSelectedIds.includes(yarnId)) {
                selectYarn(
                    yarnId,
                    option.dataset.yarnName,
                    option.dataset.yarnBrand,
                    option.dataset.yarnColorway,
                    option.dataset.yarnDyeLot,
                    option.dataset.yarnImage,
                );
            }
        });
        {% endif %}

        function updateSelectedDisplay() {
            if (selectedYarns.size === 0 && pendingYarns.size === 0) {
                selectedContainer.innerHTML = '<span class="text-base-content/40 text-sm">{{ _("No yarns selected") }}</span>';
                return;
            }

            selectedContainer.innerHTML = '';
            
            // Render existing yarns
            selectedYarns.forEach((yarn, id) => {
                const chip = document.createElement('div');
                chip.className = 'flex items-center gap-2 py-2 px-3 bg-primary/10 text-primary border border-primary/20 rounded-lg';

                const imageHtml = yarn.imageUrl
                    ? `<img src="${yarn.imageUrl}" alt="${yarn.name}" class="w-8 h-8 rounded object-cover" onerror="this.replaceWith(this.parentElement.querySelector('[data-fallback-icon]').cloneNode(true)); this.parentElement.querySelector('[data-fallback-icon]').classList.remove('hidden')">`
                    : '';

                chip.innerHTML = `
                    ${imageHtml}
                    <div class="w-8 h-8 rounded bg-base-300 flex items-center justify-center text-base-content/60${yarn.imageUrl ? ' hidden' : ''}" data-fallback-icon>
                        <span class="mdi mdi-image-off text-sm" aria-hidden="true"></span>
                    </div>
                    <span class="text-sm flex-1">
                        ${yarn.name}${yarn.brand ? ` â€¢ ${yarn.brand}` : ''}
                    </span>
                    <button type="button" class="btn btn-ghost btn-xs btn-circle" data-remove-yarn="${id}">
                        <span class="mdi mdi-close"></span>
                    </button>
                `;
                selectedContainer.appendChild(chip);

                chip.querySelector('[data-remove-yarn]').addEventListener('click', () => {
                    removeYarn(id);
                });
            });

            // Render pending yarns
            pendingYarns.forEach(name => {
                const chip = document.createElement('div');
                chip.className = 'flex items-center gap-2 py-2 px-3 bg-secondary/10 text-secondary border border-secondary/20 rounded-lg';

                chip.innerHTML = `
                    <div class="relative w-8 h-8 rounded bg-base-300 flex items-center justify-center text-base-content/60">
                        <span class="mdi mdi-sheep text-sm" aria-hidden="true"></span>
                        <span class="absolute -top-1.5 -right-1.5 badge badge-secondary font-black text-[8px] h-3 min-h-0 px-1 border-none shadow-sm scale-90">NEW</span>
                    </div>
                    <div class="flex-1 min-w-0">
                        <span class="text-sm block truncate">${name}</span>
                    </div>
                    <button type="button" class="btn btn-ghost btn-xs btn-circle" data-remove-pending="${name}">
                        <span class="mdi mdi-close"></span>
                    </button>
                `;
                selectedContainer.appendChild(chip);

                chip.querySelector('[data-remove-pending]').addEventListener('click', () => {
                    removePendingYarn(name);
                });
            });
        }

        function updateHiddenInput() {
            hiddenInput.value = Array.from(selectedYarns.keys()).join(',');
            
            const yarnTextHidden = document.getElementById('yarn_text_hidden');
            if (yarnTextHidden) {
                yarnTextHidden.value = Array.from(pendingYarns).join('\n');
            }
            
            // Explicitly clear yarn_search if we have pending yarns as chips
            const searchInput = document.getElementById('yarn_search');
            if (searchInput && pendingYarns.size > 0 && document.activeElement !== searchInput) {
                // If the user isn't typing, make sure it's clean
                if (searchInput.value.includes('\n') || Array.from(pendingYarns).some(y => searchInput.value.includes(y))) {
                    searchInput.value = '';
                }
            }
        }

    function filterOptions() {
        const searchTerm = searchInput.value.toLowerCase();
        let visibleCount = 0;

        yarnOptions.forEach(option => {
            const yarnId = parseInt(option.dataset.yarnId);
            const isSelected = selectedYarns.has(yarnId);
            const name = option.dataset.yarnName.toLowerCase();
            const brand = (option.dataset.yarnBrand || '').toLowerCase();
            const colorway = (option.dataset.yarnColorway || '').toLowerCase();
            const dyeLot = (option.dataset.yarnDyeLot || '').toLowerCase();
            const matchesSearch =
                !searchTerm
                || name.includes(searchTerm)
                || brand.includes(searchTerm)
                || colorway.includes(searchTerm)
                || dyeLot.includes(searchTerm);

            if (!isSelected && matchesSearch) {
                option.classList.remove('hidden');
                visibleCount++;
            } else {
                option.classList.add('hidden');
            }
        });

        if (visibleCount > 0 && (searchInput === document.activeElement || searchTerm)) {
            dropdown.classList.remove('hidden');
        } else {
            dropdown.classList.add('hidden');
        }
    }

    searchInput.addEventListener('focus', () => {
        filterOptions();
    });

    searchInput.addEventListener('input', () => {
        filterOptions();
    });

    searchInput.addEventListener('blur', (e) => {
        setTimeout(() => {
            if (!dropdown.contains(document.activeElement)) {
                dropdown.classList.add('hidden');
            }
        }, 200);
    });

    yarnOptions.forEach(option => {
        option.addEventListener('click', (e) => {
            e.preventDefault();
            const yarnId = parseInt(option.dataset.yarnId);
            const yarnName = option.dataset.yarnName;
            const yarnBrand = option.dataset.yarnBrand;
            const yarnColorway = option.dataset.yarnColorway;
            const yarnDyeLot = option.dataset.yarnDyeLot;
            const yarnImage = option.dataset.yarnImage;

            selectYarn(yarnId, yarnName, yarnBrand, yarnColorway, yarnDyeLot, yarnImage);
            searchInput.value = '';
            searchInput.focus();
        });
    });

    document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !dropdown.contains(e.target)) {
            dropdown.classList.add('hidden');
        }
    });
}

    function setupTextareaDrop(textarea) {
        textarea.addEventListener('dragover', (e) => {
            e.preventDefault();
            textarea.classList.add('border-blue-500', 'ring-2', 'ring-blue-500');
        });

        textarea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            textarea.classList.remove('border-blue-500', 'ring-2', 'ring-blue-500');
        });

        textarea.addEventListener('drop', async (e) => {
            e.preventDefault();
            textarea.classList.remove('border-blue-500', 'ring-2', 'ring-blue-500');

            const files = e.dataTransfer.files;
            if (files && files.length > 0) {
                const imageFiles = Array.from(files).filter(file => file.type.startsWith('image/'));
                if (imageFiles.length === 0) return;

                const stepItem = textarea.closest('.step-item');
                let sid = stepItem ? stepItem.getAttribute('data-step-id') : null;

                if (stepItem && !sid) {
                    sid = await ensureStepId(stepItem);
                    if (!sid) return;
                }

                if (!sid && !projectId) {
                    if (!(await ensureProjectId())) return;
                }

                for (const file of imageFiles) {
                    await uploadAndInsertImage(file, textarea, sid);
                }
                return;
            }

            const text = e.dataTransfer.getData('text/plain');
            if (text) {
                insertAtCursor(textarea, text);
            }
        });
    }

    function handleImageDragStart(event) {
        // Find the anchor element (either target itself or parent)
        const anchor = event.target.tagName === 'A' ? event.target : event.target.closest('a');
        if (!anchor) return;

        const src = anchor.getAttribute('href');
        const alt = anchor.getAttribute('data-pswp-caption') || (anchor.querySelector('img')?.alt) || "";
        const markdown = `![${alt}](${src})`;

        // Debug
        console.log('Dragging image as markdown:', markdown);

        // Set data
        event.dataTransfer.setData('text/plain', markdown);
        event.dataTransfer.effectAllowed = 'copy';

        // Important: set dropEffect in dragover/drop handlers, here we just set effectAllowed
    }
    function insertAtCursor(textarea, text) {
        const start = textarea.selectionStart;
        const end = textarea.selectionEnd;
        const val = textarea.value;
        textarea.value = val.substring(0, start) + text + val.substring(end);
        textarea.selectionStart = textarea.selectionEnd = start + text.length;
        textarea.focus();
        textarea.dispatchEvent(new Event('input', { bubbles: true }));
        autoResize(textarea);
    }
    /**
     * Helper to create a unified image preview card in JavaScript.
     * Matches the image_preview Jinja macro.
     */
    function createImagePreviewHTML(imageData, options = {}) {
        const {
            showPromote = false,
            showDelete = true,
            isPrimary = false,
            projectId = window.projectId,
            imageClass = 'h-32'
        } = options;

        const pswpWidth = imageData.width || 1200;
        const pswpHeight = imageData.height || 1200;
        const altText = imageData.alt_text || "";
        const thumbUrl = imageData.thumbnail_url || imageData.url;

        return `
        <div class="relative group" data-image-id="${imageData.id}">
            <a href="${imageData.url}" 
               data-pswp-width="${pswpWidth}"
               data-pswp-height="${pswpHeight}" 
               data-pswp-caption="${altText}" 
               ${showPromote ? 'data-pswp-promote="true"' : ''}
               ${showDelete ? 'data-pswp-delete="true"' : ''}
               data-pswp-is-primary="${isPrimary ? 'true' : 'false'}"
               draggable="true" ondragstart="handleImageDragStart(event)"
               class="block">
                <img src="${thumbUrl}" 
                     alt="${altText}" 
                     class="${imageClass} w-full cursor-zoom-in rounded object-cover shadow dark:shadow-slate-900/30">
            </a>
            ${showPromote ? `
            <button type="button" onclick="promoteImage(${projectId}, ${imageData.id})"
                class="title-promote-btn absolute top-1 left-1 z-10 rounded-full p-1 shadow-sm transition-all ${isPrimary ? 'bg-amber-400 text-white opacity-100' : 'bg-white/90 text-slate-400 opacity-0 group-hover:opacity-100 dark:bg-slate-900/90 dark:text-slate-500'} hover:bg-amber-50 hover:text-amber-600 dark:hover:bg-amber-900/50 dark:hover:text-amber-400"
                title="{{ _('Make title image') }}">
                <span class="mdi ${isPrimary ? 'mdi-star' : 'mdi-star-outline'}"></span>
            </button>
            ` : ''}
            ${showDelete ? `
            <button type="button" onclick="deleteImage(${imageData.id})"
                class="absolute top-1 right-1 z-10 bg-red-600 text-white rounded-full p-1 hover:bg-red-700 dark:hover:bg-red-500 shadow-sm opacity-0 group-hover:opacity-100 transition-opacity">
                <span class="mdi mdi-delete"></span>
            </button>
            ` : ''}
        </div>
        `;
    }

    async function uploadAndInsertImage(file, textarea, stepId) {
        if (!stepId && !(await ensureProjectId())) return;

        const formData = new FormData();
        formData.append('file', file);
        formData.append('alt_text', file.name);

        const url = stepId
            ? `/projects/${projectId}/steps/${stepId}/images` 
            : `/projects/${projectId}/images/title`;

        try {
            window.showToast?.('{{ _("Uploading image...") }}', 'info');
            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'X-CSRF-Token': '{{ csrf_token }}'
                },
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                const markdown = `![${data.alt_text}](${data.url})`;
                insertAtCursor(textarea, markdown);
                window.showToast?.('{{ _("Image uploaded!") }}', 'success');
                window.unsavedChanges?.setDirty(true);

                if (stepId) {
                    const stepItem = document.querySelector(`.step-item[data-step-id="${stepId}"]`);
                    if (stepItem) {
                        addStepImagePreview(stepItem, data);
                    }
                } else {
                    addTitleImageToGallery(data);
                }
            } else {
                window.showToast?.('{{ _("Upload failed") }}', 'error');
            }
        } catch (error) {
            console.error('Upload failed', error);
            window.showToast?.('{{ _("Upload failed") }}', 'error');
        }
    }
</script>

<script>
    let projectId = {{ (project.id if project else none) | tojson }};
    let wasSilentlyCreated = false;

    // Initialize discard hook
    document.addEventListener('DOMContentLoaded', () => {
        if (window.unsavedChanges) {
            window.unsavedChanges.onBeforeDiscard = async () => {
                if (wasSilentlyCreated && projectId) {
                    console.log('Discarding silent project:', projectId);
                    try {
                        const response = await fetch(`/projects/${projectId}`, {
                            method: 'DELETE',
                            headers: {
                                'HX-Request': 'true', // Trigger HTMX-like response if needed, although we are navigating away
                                'X-CSRF-Token': '{{ csrf_token }}'
                            }
                        });
                        if (!response.ok) {
                            console.error('Failed to delete silent project');
                        }
                    } catch (error) {
                        console.error('Error deleting silent project:', error);
                    }
                }
            };
        }
    });

    /**
     * Ensures the project exists before performing actions that require a projectId.
     * If project doesn't exist, it performs a minimal save to get an ID.
     */
    async function ensureProjectId() {
        if (projectId) return true;

        const nameInput = document.getElementById('name');
        if (nameInput && !nameInput.value.trim()) {
            const now = new Date();
            const dateStr = now.getFullYear() + '-' +
                String(now.getMonth() + 1).padStart(2, '0') + '-' +
                String(now.getDate()).padStart(2, '0');
            nameInput.value = `{{ _("New Project") }} ${dateStr}`;
        }

        const formData = new FormData(document.getElementById('projectForm'));

        try {
            const response = await fetch('/projects', {
                method: 'POST',
                headers: {
                    'Accept': 'application/json',
                    'X-CSRF-Token': '{{ csrf_token }}'
                },
                body: formData
            });

            if (response.ok) {
                const data = await response.json();
                projectId = data.id;
                wasSilentlyCreated = true;
                window.unsavedChanges?.setDirty(true);

                // Update form action and other links
                const form = document.getElementById('projectForm');
                if (form) {
                    form.action = `/projects/${projectId}`;
                }

                // Update back button link
                const backBtn = document.querySelector('[data-unsaved-confirm]');
                if (backBtn && backBtn.tagName.toLowerCase() === 'a') {
                    backBtn.href = '/projects';
                }

                // Update browser URL without reloading
                window.history.replaceState({}, '', `/projects/${projectId}/edit`);
                return true;
            } else {
                window.showToast?.('{{ _("Failed to initialize project") }}', 'error');
                return false;
            }
        } catch (error) {
            console.error('Project initialization failed', error);
            window.showToast?.('{{ _("Network error") }}', 'error');
            return false;
        }
    }

    const uploadInstructionsText = '{{ _("Drag and drop images here or click to upload") }}';
    const stepUploadDisabledMessage = '{{ _("Save the project before adding images to this step") }}';
    const uploadErrorMessage = '{{ _("Image upload failed. Please try again") }}';
    const uploadNetworkErrorMessage = '{{ _("Network error while uploading image") }}';
    const unsupportedFileMessage = '{{ _("Only image files are supported") }}';
    const deleteErrorMessage = '{{ _("Failed to delete the image. Please try again") }}';
    const deleteNetworkErrorMessage = '{{ _("Network error while deleting image") }}';
    const uploadingMessage = '{{ _("Uploadingâ€¦") }}';

    const parseErrorMessage =
        typeof extractErrorMessage === 'function'
            ? extractErrorMessage
            : async (_response, fallback) => fallback;

    function bindPendingStepDropzone(dropzone, input, instructions) {
        if (!dropzone || dropzone.dataset.pendingBound === 'true') {
            return;
        }

        dropzone.dataset.pendingBound = 'true';
        dropzone.classList.add('opacity-60', 'cursor-not-allowed');
        dropzone.classList.remove('pointer-events-none');
        dropzone.setAttribute('aria-disabled', 'true');

        if (instructions) {
            instructions.textContent =
                instructions.dataset.disabledText || stepUploadDisabledMessage;
        }

        const showDisabledToast = () => {
            window.showToast?.(stepUploadDisabledMessage, 'info');
        };

        dropzone.addEventListener('click', (event) => {
            event.preventDefault();
            showDisabledToast();
        });

        ['dragover', 'drop'].forEach((eventName) => {
            dropzone.addEventListener(eventName, (event) => {
                event.preventDefault();
                event.stopPropagation();
                if (eventName === 'dragover') {
                    dropzone.classList.add('border-blue-500');
                } else {
                    dropzone.classList.remove('border-blue-500');
                    showDisabledToast();
                }
            });
        });

        dropzone.addEventListener('dragleave', (event) => {
            event.preventDefault();
            event.stopPropagation();
            dropzone.classList.remove('border-blue-500');
        });

        const label = dropzone.querySelector('label');
        if (label) {
            ['click', 'dragover', 'drop', 'dragleave'].forEach((eventName) => {
                label.addEventListener(eventName, (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    if (eventName === 'dragover') {
                        dropzone.classList.add('border-blue-500');
                        return;
                    }

                    if (eventName === 'dragleave') {
                        dropzone.classList.remove('border-blue-500');
                        return;
                    }

                    if (eventName === 'drop') {
                        dropzone.classList.remove('border-blue-500');
                    }

                    showDisabledToast();
                });
            });
        }

        input.addEventListener('change', (event) => {
            event.preventDefault();
            input.value = '';
            showDisabledToast();
        });
    }

    function deleteProject() {
        const deleteYarns = document.getElementById('delete_exclusive_yarns')?.checked || false;
        const url = new URL('/projects/{{ project.id }}', window.location.origin);
        if (deleteYarns) {
            url.searchParams.set('delete_yarns', 'true');
        }

        fetch(url, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': '{{ csrf_token }}'
            }
        }).then(response => {
            if (response.ok) {
                window.location.href = '/projects';
            }
        });
    }
</script>
{% endblock %}